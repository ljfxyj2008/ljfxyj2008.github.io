<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description"/><title>《Think in Java》并发 - 学习笔记 | ljfxyj2008的小站</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/pure-min.css"/><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"/><link rel="stylesheet" type="text/css" href="/css/style.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" href="/atom.xml"/></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《Think in Java》并发 - 学习笔记</h1><a id="logo" href="/">ljfxyj2008的小站</a><p class="description">记录点滴</p></div><div id="nav-menu"><a href="/" class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">《Think in Java》并发 - 学习笔记</h1><div class="post-meta">2015-09-08 | <span class="categories">分类于<a href="/categories/Java/">Java</a></span></div><span data-thread-key="2015/09/08/2015-9-8-《Think-in-Java》并发-学习笔记.html" class="ds-thread-count"></span><div class="post-content"><p>1.Executor允许你管理异步任务的执行，而无须显示地管理线程的生命周期。Executor在Java SE5/6中是启动任务的优选方法。可以使用Executor来代替显示地创建Thread对象。  </p>
<p>2.ExecutorService知道如何构建恰当的上下文来执行Runnable对象。  </p>
<p>3.CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后再它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。只有当这种方式会引发问题时，才需要切换到FixedThreadPool。</p>
<p>4.SingleThreadExecutor就像是线程数量为1的FixedThreadPool。如果向SingleThreadExecutor提交了多个任务，那么这些任务将排队，每个任务都会在下一个任务开始之前运行结束，所有的任务将使用相同的线程。SingleThreadExecutor会序列化所有提交给它的任务，并会维护它自己（隐藏）的悬挂任务队列。<br>SingleThreadExecutor确保任何时刻在任何线程中都只有唯一的任务在运行，就不需要在共享资源上处理同步。  </p>
<p>5.Runnable是执行工作的独立任务，但是他不返回任何值。如果希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口。在Java SE5中引入的Callable是一种具有类型参数的泛型，它的类型参数表示的是从方法call（）（而不是run（））中返回的值，并且必须使用ExecutorService.submit（）方法调用它。<br>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread.sleep((<span class="keyword">new</span> Random()).nextInt(<span class="number">2000</span>) + <span class="number">1000</span>);<span class="comment">//在这里随机睡眠时间，为了测试Future.isDone()的效果</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"TaskWithResult id: "</span> + id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">		ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			results.add(exec.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(Future&lt;String&gt; fs : results)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"\n==taskIndex "</span> + results.indexOf(fs) + <span class="string">"=="</span>);</span><br><span class="line">				System.out.println(<span class="string">"isDone(): "</span> + fs.isDone());</span><br><span class="line">				System.out.println(fs.get());</span><br><span class="line">				System.out.println(<span class="string">"isDone(): "</span> + fs.isDone());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">				exec.shutdown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<blockquote>
<p>==taskIndex 0==<br>isDone(): false<br>TaskWithResult id: 0<br>isDone(): true</p>
<p>==taskIndex 1==<br>isDone(): false<br>TaskWithResult id: 1<br>isDone(): true</p>
<p>==taskIndex 2==<br>isDone(): true<br>TaskWithResult id: 2<br>isDone(): true</p>
<p>==taskIndex 3==<br>isDone(): false<br>TaskWithResult id: 3<br>isDone(): true</p>
<p>==taskIndex 4==<br>isDone(): true<br>TaskWithResult id: 4<br>isDone(): true</p>
<p>==taskIndex 5==<br>isDone(): true<br>TaskWithResult id: 5<br>isDone(): true</p>
<p>==taskIndex 6==<br>isDone(): true<br>TaskWithResult id: 6<br>isDone(): true</p>
<p>==taskIndex 7==<br>isDone(): false<br>TaskWithResult id: 7<br>isDone(): true</p>
<p>==taskIndex 8==<br>isDone(): true<br>TaskWithResult id: 8<br>isDone(): true</p>
<p>==taskIndex 9==<br>isDone(): true<br>TaskWithResult id: 9<br>isDone(): true</p>
</blockquote>
<p>且每当输出到isDone(): false的地方，输出线程就会卡住，直到取到这个线程的返回值后，才会继续后续的打印。  </p>
<p>Future的javadoc说明如下：  </p>
<blockquote>
<p>A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the cancel method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future&lt;?&gt; and return null as a result of the underlying task.</p>
</blockquote>
<p>Future.get()方法的javadoc说明如下：  </p>
<blockquote>
<p>Waits if necessary for the computation to complete, and then retrieves its result.</p>
</blockquote>
<p>6.调度器倾向于让优先级最高的线程先执行。如果要设置线程的优先级，应该在run（）方法体中使用<br><code>Thread.currentThread().setPriority(newPriority)</code>来设置，而不要在构造器中设置。<br>不同操作系统对优先级的分级不同，为了可移植性，应该只使用MAX_PRIORITY、NORM_PRIORITY和MIN_PRIORITY三种级别。  </p>
<p>7.yield（）方法会暗示线程调度器，我的工作做得差不多了，具有相同优先级的其他线程可以运行了。但这仅仅是一个暗示，没有任何机制保证它将被采纳。所以，不能依赖于yield（）。实际上，yield（）经常被误用。  </p>
<p>8.所谓后台（daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，<strong>当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程</strong>。反过来说，只要有任何非后台线程还在运行，程序就不会终止。<br>必须在线程启动之前调用setDaemon（）方法才能把它设置为后台线程，如以下代码： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread daemon = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SimpleDaemon());</span><br><span class="line">daemon.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">daemon.start();</span><br></pre></td></tr></table></figure>
<p>可以用isDaemon()方法来确定线程是否是一个后台线程。如果是一个后台线程，那么它创建的任何子线程都将被自动设置成后台线程。</p>
<p>9.是线程睡眠时可以调用  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.MILLISECONDS.sleep(timeout);</span><br><span class="line">TimeUnit.HOURS.sleep(timeout);</span><br><span class="line">TimeUnit.MICROSECONDS.sleep(timeout);</span><br></pre></td></tr></table></figure>
<p>等方法来代替直接调用<code>Thread.sleep(timeout)</code>方法，这样时间的长度就更直观，这些方法内部会自动调用Thread.sleep(timeout)方法。  </p>
<p>10.join()方法：  </p>
<ul>
<li>一个线程可以在其他线程之上调用join（）方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程t上调用t.join()，此线程将被挂起，直到目标线程t结束才恢复（即t.isAlive()返回为假）。  </li>
<li>可以在调用join()时带上一个超时参数（单位可以是毫秒，或者毫秒和纳秒），这样如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回。</li>
<li>对join()方法的调用可以被中断，做法是在调用join（）的线程上再次调用interrupt()方法。  </li>
</ul>
<p>11.由于线程的本质特性，不能捕获从线程中逃逸的异常，即使在主线程中执行子线程任务时把它包在try-catch块中，任然无法捕获到逃逸的异常，异常会直接向外传播的控制台。为了捕获异常，可以在每个新创建的Thread对象上附着一个Thread.UncaughtExceptionHandler。</p>
<p>例如下面的代码：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"I throw this Exception on purpose!"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExceptionCaughtTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">			t1.start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.out.println(<span class="string">"Haha! Exception caught!!!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行的结果为：  </p>
<blockquote>
<p>Exception in thread “Thread-0” java.lang.RuntimeException: I throw this Exception on purpose!<br>    at MyThread.run(ThreadExceptionCaughtTest.java:5)</p>
</blockquote>
<p>可见try-catch并不能捕获到我在MyThread中抛出的异常。  </p>
<p>那么我为MyThread附加一个我自己实现的UncaughtExceptionHandler，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"I throw this Exception on purpose!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Haha! I caught : "</span> + e);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExceptionCaughtTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">			t1.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">			t1.start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.out.println(<span class="string">"Haha! Exception caught!!!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
<p>执行的结果为：</p>
<blockquote>
<p>Haha! I caught : java.lang.RuntimeException: I throw this Exception on purpose!</p>
</blockquote>
<p>可以看到MyUncaughtExceptionHandler成功捕获到了MyThread抛出的异常，try-catch仍然没有捕获到异常。  </p>
<p>12.关于<strong>synchronized方法</strong><br>所有对象都自动含有单一的锁（也称为监视器）。当在对象上调用其任意synchronized方法的时候，此对象都被加锁，<strong>这时该对象上的其他synchronized方法只有等到前一个方法调用完毕并释放了锁之后才能被调用</strong>。<br>例如这段代码：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAccount</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> account;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserAccount</span><span class="params">(<span class="keyword">int</span> account)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.account = account;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">			System.out.println(<span class="string">"incAccount result: "</span> + ++account);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"decAccount result: "</span> + --account);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		UserAccount ua = <span class="keyword">new</span> UserAccount(<span class="number">200</span>);</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				ua.incAccount();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				ua.decAccount();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(<span class="string">"===start==="</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
<p>其执行结果始终为：  </p>
<blockquote>
<p>===start===<br>incAccount result: 201<br>decAccount result: 200</p>
</blockquote>
<p>且控制台打印出“===start===”后，会暂停2秒钟才继续输出后面的2行结果。</p>
<p>而如果把函数decAccount（）前面的synchronized修饰符去掉，则打印结果为：   </p>
<blockquote>
<p>===start===<br>decAccount result: 199<br>incAccount result: 200</p>
</blockquote>
<p>且前两行结果是瞬间打印出来的，然后暂停了2秒，才输出最后一行结果。  </p>
<p>13.在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突。<br>如果你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关的方法。</p>
<p>14.一个任务可以多次获得对象的锁。JVM负责跟踪对象被加锁的次数。只有首先获得了锁的任务才能允许继续获取多个锁。  </p>
<p>15.针对每个类，也有一个锁，作为类的Class对象的一部分，所以synchronized static方法可以在类的范围内防止对static数据的并发访问。  </p>
<p>16.在java.util.concurrent.locks中定义了显示的互斥机制Lock。Lock对象必须被显示地创建、锁定和释放。<br>好的使用习惯是，使用try-finally语句块，将lock（）放在try中，将unlock（）放在finally中。注意，return语句必须放在try子句中，以确保unlock（）不会过早发生，从而将数据暴露给第二个任务。  </p>
<p>17.如果将一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改。即便使用了本地缓存，情况也确实如此，volatile域会立即被写入到主存中，而读取操作就发生在主存中。<br>如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则，这个域就应该只能经由同步来访问。同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护，那就不必将其设置为是volatile的。<br>使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域。你的第一选择应该是使用synchronized关键字，这是最安全的方式，而尝试其他任何方式都是有风险的。（我理解这句话想表达的意思是，尽量不要使用volatile关键字，而是使用synchronized关键字或者Lock类。）  </p>
<p>18.调用sleep()和yield（）的时候并没有释放锁。<br>调用wait()的时候锁被释放。<br>wait()、notify（）以及notifyAll()有一个比较特殊的方面，那就是这些方法是基类Object的一部分，而不是属于Thread的一部分，只能在synchronized方法或synchronized块中调用这几个方法。sleep（）可以在非synchronized控制方法里调用，是因为不用操作锁。</p>
</div><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/多线程/">多线程</a><a href="/tags/并发/">并发</a></div><div class="post-nav"><a href="/2015/09/14/2015-9-14-EventBus学习总结.html" class="pre"><i class="icon-previous">EventBus学习总结</i></a><a href="/2013/12/02/2013-12-2-FLEX无法启动服务因为fml文件损坏.html" class="next">【FLEX bug:无法启动服务，因为fml文件损坏】的解决办法<i class="icon-next"></i></a></div><div data-thread-key="2015/09/08/2015-9-8-《Think-in-Java》并发-学习笔记.html" data-title="《Think in Java》并发 - 学习笔记" data-url="http://www.carrotsight.com/2015/09/08/2015-9-8-《Think-in-Java》并发-学习笔记.html" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2015/09/08/2015-9-8-《Think-in-Java》并发-学习笔记.html" data-title="《Think in Java》并发 - 学习笔记" data-url="http://www.carrotsight.com/2015/09/08/2015-9-8-《Think-in-Java》并发-学习笔记.html" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><input placeholder="Search" type="text" class="st-default-search-input"/></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flex/">Flex</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/EventBus/" style="font-size: 15px;">EventBus</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/reflection/" style="font-size: 15px;">reflection</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/Otto/" style="font-size: 15px;">Otto</a> <a href="/tags/观察者模式/" style="font-size: 15px;">观察者模式</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/库项目/" style="font-size: 15px;">库项目</a> <a href="/tags/facebook/" style="font-size: 15px;">facebook</a> <a href="/tags/FlatBuffers/" style="font-size: 15px;">FlatBuffers</a> <a href="/tags/Google/" style="font-size: 15px;">Google</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2015/11/13/一个android日志库的实现.html">一个android日志库的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/10/FlatBuffers学习总结.html">FlatBuffers学习总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/19/2015-9-19-Android编程要注意的安全规范.html">Android编程要注意的安全规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/16/2015-9-16-《Think-in-Java》类型信息-–-学习笔记.html">《Think in Java》类型信息 – 学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/15/2015-9-15-Otto学习笔记.html">Otto学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/14/2015-9-14-EventBus学习总结.html">EventBus学习总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/08/2015-9-8-《Think-in-Java》并发-学习笔记.html">《Think in Java》并发 - 学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/12/02/2013-12-2-FLEX无法启动服务因为fml文件损坏.html">【FLEX bug:无法启动服务，因为fml文件损坏】的解决办法</a></li><li class="post-list-item"><a class="post-list-link" href="/2013/04/03/2013-4-3-Flex中datagrid中checkbox的全选实现.html">Flex中datagrid中checkbox的全选实现</a></li></ul></div><div class="widget"><div class="comments-title">最近评论</div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title">友情链接</div></div></div></div></div><div id="footer">© <a href="/" rel="nofollow">ljfxyj2008的小站.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>var duoshuoQuery = {short_name:'carrotsight'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

_st('install','dMqdYr62RGqqfwhQNdbT','2.0.0');
</script><script>(function(){
var bp = document.createElement('script');
bp.src = '//push.zhanzhang.baidu.com/push.js';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(bp, s);
})();</script></div></body></html>