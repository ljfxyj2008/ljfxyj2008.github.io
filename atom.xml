<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ljfxyj2008的小站]]></title>
  <subtitle><![CDATA[记录点滴]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.carrotsight.com/"/>
  <updated>2015-12-03T08:08:34.000Z</updated>
  <id>http://www.carrotsight.com/</id>
  
  <author>
    <name><![CDATA[ljfxyj2008]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[一个android日志库的实现]]></title>
    <link href="http://www.carrotsight.com/2015/11/13/%E4%B8%80%E4%B8%AAandroid%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <id>http://www.carrotsight.com/2015/11/13/一个android日志库的实现.html</id>
    <published>2015-11-13T06:12:58.000Z</published>
    <updated>2015-12-03T08:08:34.000Z</updated>
    <content type="html"><![CDATA[<h1 id="调研">调研</h1><p>在android开发中，如果需要打印调试信息，往往会使用Log.d()、Log.e()之类的由android.util.Log提供的方法。它的好处是简单、方便，不足也很明显，可定制性差，不能打印到文件。如果想在发行版app中的某些关键语句打印log到文件，或者在app崩溃时把崩溃信息打印到文件供上传分析，那么android.util.Log就无能为力了。<br><a id="more"></a><br>在网上做了一下android平台日志库的调研，挑出一些比较有代表性有影响力的，大致结果如下：</p>
<blockquote>
<p>①orhanobut/logger：<br>来自github.com，截止2015年11月10日15:53:20该项目已经有1996颗星！！！<br>地址：<a href="https://github.com/orhanobut/logger" target="_blank" rel="external">https://github.com/orhanobut/logger</a></p>
<p>②JakeWharton/timber：<br>来自github.com，截止2015年11月10日15:54:22该项目已经有1571颗星！！！<br>地址：<a href="https://github.com/JakeWharton/timber" target="_blank" rel="external">https://github.com/JakeWharton/timber</a></p>
<p>③noveogroup/android-logger：<br>来自github.com，截止2015年11月10日15:55:56该项目已经有125颗星（跟上面两位比差的挺多）。<br>地址：<a href="https://github.com/noveogroup/android-logger" target="_blank" rel="external">https://github.com/noveogroup/android-logger</a></p>
<p>④SLF4J：<br>它只是一个对log系统进行抽象的表现形式，不是具体的实现。它支持第三方log框架，比如log4j等。如果需要指定第三方log框架，只需要在运行时把对应的slf4j的jar文件放在你的class path中，系统会自动bind该log框架。比如，要从java.util.logging中切换到log4j，只需要把slf4j-jdk-1.7.12.jar替换为slf4j-log4j12-1.7.12.jar即可。<br>地址：<a href="http://www.slf4j.org/download.html" target="_blank" rel="external">http://www.slf4j.org/download.html</a></p>
<p>⑤SLF4J-Android：<br>SLF4J-Android是对SLF4J的API的重新包装，以及一个轻量级的bind实现。该实现简单的把所有的SLF4J的log请求都用Android的Log工具进行了替换。功能与SLF4J类似。不过只支持23个字符长度的Tag，例如com.example.myapp.MyClass会被截断为c*.e*.m*.MyClass，会导致不同的类在tag中显示同样的名称，引起混淆。<br>地址：<a href="http://www.slf4j.org/android/" target="_blank" rel="external">http://www.slf4j.org/android/</a></p>
<p>⑥ LOGBack：<br>LOGBack与Log4J的作者是同一个人。作者更推荐使用LOGBack。具作者说LOGBack在某些苛刻的执行路径下，比log4j差不多要快10倍，经过了长期而广泛的测试，比log4j更为可靠。不过这货是个重量级选手，功能太全，体积庞大。<br>地址：<a href="http://logback.qos.ch/" target="_blank" rel="external">http://logback.qos.ch/</a></p>
<p>⑦android-logging-log4j：<br>内部使用log4j，支持slf4j;适用于log4j的LogCatAppender，它能够把log打印到LogCat;提供了一个log4j的配置装饰类，用它能够方便地配置Log4J;同时不需要修改log4j.jar文件。<br>地址：<a href="https://code.google.com/p/android-logging-log4j/" target="_blank" rel="external">https://code.google.com/p/android-logging-log4j/</a></p>
</blockquote>
<p>前三个库是专为android设计的，可以看到支持者众多，不过它们内部实现上也是调用android.util.Log的方法打印到控制台，不能满足我们的需求。后面的几个库中有一些选手非常全能，不过体积较大，很多功能是我们不需要的，而且它也无法很方便的扩展自定义的日志实现，比如app崩溃信息获取、日志文件后台上传等。于是乎开始自己动手实现一个既方便实用，能覆盖基本的控制台、文件输出，又便于自定义扩展的android日志库。</p>
<h1 id="gradle直接配置日志库">gradle直接配置日志库</h1><p>log4j最强大方便的地方应该就是它可以直接通过property文件进行配置。这里由于我们实用Android Studio进行开发，所以希望能够直接通过build.gradle文件对我们的日志库进行配置。在网上搜索了良久，发现可以在buildTypes中分别为debug版本和release版本（甚至更多其他自定义版本）定义不同的buildConfigField参数，然后在java代码中通过自动生成的BuildConfig文件进行读取。</p>
<p>例如，我在module的build.grade文件中做了如下配置：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Logger settings for release mode</span></span><br><span class="line">            <span class="comment">//以下是配置MyLog打印功能的各项参数</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"logLevel"</span>, <span class="string">"\"VERBOSE\""</span>)<span class="comment">//设置当前log的打印级别。支持的打印级别分别为：VERBOSE,DEBUG,INFO,WARN,ERROR,ASSERT。与logcat的级别一一对应。只有等于或高于此级别的log才会被打印出来。</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"logToSDDirName"</span>, <span class="string">"\"MyLogs-release\""</span>)<span class="comment">//如果设置了打印到文件，则此字段指定把日志打印到SD卡的哪个目录</span></span><br><span class="line">            buildConfigField(<span class="string">"int"</span>, <span class="string">"singleLogFileSizeLimit"</span>, <span class="string">"10"</span>)<span class="comment">//如果设置了打印到文件，则此字段设置单个log文件的大小上限，单位是MB</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            <span class="comment">//Logger settings for debug mode</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"logLevel"</span>, <span class="string">"\"DEBUG\""</span>)<span class="comment">//设置当前log的打印级别。支持的打印级别分别为：VERBOSE,DEBUG,INFO,WARN,ERROR,ASSERT。与logcat的级别一一对应。只有等于或高于此级别的log才会被打印出来。</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"logToSDDirName"</span>, <span class="string">"\"MyLogs-debug\""</span>)<span class="comment">//如果设置了打印到文件，则此字段指定把日志打印到SD卡的哪个目录</span></span><br><span class="line">            buildConfigField(<span class="string">"int"</span>, <span class="string">"singleLogFileSizeLimit"</span>, <span class="string">"10"</span>)<span class="comment">//如果设置了打印到文件，则此字段设置单个log文件的大小上限，单位是MB</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么就可以在对应module的java代码中进行读取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = BuildConfig.logMethodDepth;</span><br></pre></td></tr></table></figure>
<p>这个方案并没有问题，不过接下来却踩进了一个坑，因为我下意识的把这些配置都写在了我的Log库module中，同样，对配置参数（如logMethodDepth等）的读取也是在Log库module的java代码中。这样就带来两个问题，也是后来才意识到的：</p>
<ul>
<li>坑①：<br>Gradle目前有一个bug：你在库项目的build.gradle中定义了release和debug两种配置，然后不论你的Build Variants是选择debug还是release，默认都只会编译release版本。在stackoverflow上搜索后发现好几年前就已经有人在提这个问题了，不过直到日前在android开发者网站上仍然把这个问题列为希望在将来解决的问题。不过这个问题后来通过一个比较绕的方法解决了，就是在Log库module的build.gradle中加入defaultPublishConfig配置，变成这样：</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果要使用buildTypes中debug版的log配置，则设置为debug；否则，设置为release</span></span><br><span class="line">        defaultPublishConfig <span class="string">"debug"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以指定是使用debug版还是release版的配置了。不过这样的库提供给用户也够麻烦的，因为用户不仅要设置自己app的buildType，还得每次手动来设置Log库module的编译type，搞不好一不小心两者设的不统一就麻烦了。</p>
<ul>
<li>坑②：<br>如果以这样的方式来配置Log库，那么用户就只能以module源码的方式将Log库引入自己的工程。如果要把Log库打成aar包提供给用户怎么办？参数就没法自定义了吧。</li>
</ul>
<p>所以，醒悟后就把对Log库的自定义配置参数从Log库的build.gradle移动到了用户app的build.gradle中，也就是在readme.md文件中说明使用方法，其中一步就是要用户与把示例代码拷贝到自己app的build.gradle中，在对Log进行初始化时进行配置参数的调用。当然，这里Log初始化的代码也是在说明文件中写好的，用户拷贝即可。</p>
<h1 id="日志写入到文件">日志写入到文件</h1><p>要实现把日志写入到sd的指定目录下，日志文件按照日期进行自动命名，每个日志文件要限制大小，达到文件大小上限后自动创建新的文件，等等。于是又google了良久，发现可以用java.util.logging.FileHandler配合java.util.logging.logger来实现。<br>要使用FileHandler，先要实现一个自己的Formatter类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFormatter</span> <span class="keyword">extends</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">        String appPackageName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyFormatter</span><span class="params">(String appPackageName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.appPackageName = appPackageName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">(LogRecord rec)</span> </span>&#123;</span><br><span class="line">            StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">            SimpleDateFormat timeFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">            buf.append(timeFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            buf.append(<span class="string">'/'</span>);</span><br><span class="line">            buf.append(appPackageName);</span><br><span class="line">            buf.append(<span class="string">' '</span>);</span><br><span class="line">            buf.append(MYLogLevel.getSimpleLevelStringByJavaLevel(rec.getLevel()));</span><br><span class="line">            buf.append(<span class="string">'/'</span>);</span><br><span class="line">            buf.append(rec.getParameters()[<span class="number">0</span>]);</span><br><span class="line">            buf.append(<span class="string">':'</span>);</span><br><span class="line">            buf.append(<span class="string">' '</span>);</span><br><span class="line">            buf.append(formatMessage(rec));</span><br><span class="line">            buf.append(<span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">return</span> buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   
<p>然后，创建一个FileHandler实例，并把MyFormatter的一个实例作为参数传给我们的FileHandler实例，并用FileHandler来作为我们的Logger的处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;                                                                                                                                        </span><br><span class="line">		Logger logger = Logger.getLogger(packageName);                                                                                       </span><br><span class="line">		logger.setUseParentHandlers(<span class="keyword">false</span>);                                                                                                  </span><br><span class="line">                                                                                                                                             </span><br><span class="line">		SimpleDateFormat dateformat1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);                                                                   </span><br><span class="line">		String datestring = dateformat1.format(<span class="keyword">new</span> Date());                                                                                  </span><br><span class="line">		fh = <span class="keyword">new</span> FileHandler(file.getAbsolutePath() + <span class="string">"_"</span> + datestring + <span class="string">"_%g"</span> + <span class="string">".log"</span>,                                                     </span><br><span class="line">				singleLogFileSizeLimit * <span class="number">1024</span> * <span class="number">1024</span>, <span class="number">9999</span>, <span class="keyword">true</span>);                                                                           </span><br><span class="line">		fh.setFormatter(<span class="keyword">new</span> MyFormatter(packageName));                                                                                       </span><br><span class="line">		logger.addHandler(fh);                                                                                                               </span><br><span class="line">                                                                                                                                             </span><br><span class="line">		<span class="keyword">return</span> logger;                                                                                                                       </span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;                                                                                                                </span><br><span class="line">		e.printStackTrace();                                                                                                                 </span><br><span class="line">		<span class="keyword">if</span> (fh != <span class="keyword">null</span>) &#123;                                                                                                                    </span><br><span class="line">			fh.close();                                                                                                                      </span><br><span class="line">		&#125;                                                                                                                                    </span><br><span class="line">                                                                                                                                             </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;                                                                                                                         </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>关于FileHandler实例化的参数，官网说明如下：</p>
<blockquote>
<p>public class FileHandler<br>extends StreamHandler<br>Simple file logging Handler.<br>The FileHandler can either write to a specified file, or it can write to a rotating set of files.<br>For a rotating set of files, as each file reaches a given size limit, it is closed, rotated out, and a new file opened. Successively older files are named by adding “0”, “1”, “2”, etc. into the base filename.<br>By default buffering is enabled in the IO libraries but each log record is flushed out when it is complete.<br>By default the XMLFormatter class is used for formatting.<br>Configuration: By default each FileHandler is initialized using the following LogManager configuration properties. If properties are not defined (or have invalid values) then the specified default values are used.<br>java.util.logging.FileHandler.level specifies the default level for the Handler (defaults to Level.ALL).<br>java.util.logging.FileHandler.filter specifies the name of a Filter class to use (defaults to no Filter).<br>java.util.logging.FileHandler.formatter specifies the name of a Formatter class to use (defaults to java.util.logging.XMLFormatter)<br>java.util.logging.FileHandler.encoding the name of the character set encoding to use (defaults to the default platform encoding).<br>java.util.logging.FileHandler.limit specifies an approximate maximum amount to write (in bytes) to any one file. If this is zero, then there is no limit. (Defaults to no limit).<br>java.util.logging.FileHandler.count specifies how many output files to cycle through (defaults to 1).<br>java.util.logging.FileHandler.pattern specifies a pattern for generating the output file name. See below for details. (Defaults to “%h/java%u.log”).<br>java.util.logging.FileHandler.append specifies whether the FileHandler should append onto any existing files (defaults to false).<br>A pattern consists of a string that includes the following special components that will be replaced at runtime:<br>“/“ the local pathname separator<br>“%t” the system temporary directory<br>“%h” the value of the “user.home” system property<br>“%g” the generation number to distinguish rotated logs<br>“%u” a unique number to resolve conflicts<br>“%%” translates to a single percent sign “%”<br>If no “%g” field has been specified and the file count is greater than one, then the generation number will be added to the end of the generated filename, after a dot.<br>Thus for example a pattern of “%t/java%g.log” with a count of 2 would typically cause log files to be written on Solaris to /var/tmp/java0.log and /var/tmp/java1.log whereas on Windows 95 they would be typically written to C:\TEMP\java0.log and C:\TEMP\java1.log<br>Generation numbers follow the sequence 0, 1, 2, etc.<br>Normally the “%u” unique field is set to 0. However, if the FileHandler tries to open the filename and finds the file is currently in use by another process it will increment the unique number field and try again. This will be repeated until FileHandler finds a file name that is not currently in use. If there is a conflict and no “%u” field has been specified, it will be added at the end of the filename after a dot. (This will be after any automatically added generation number.)<br>Thus if three processes were all trying to log to fred%u.%g.txt then they might end up using fred0.0.txt, fred1.0.txt, fred2.0.txt as the first file in their rotating sequences.<br>Note that the use of unique ids to avoid conflicts is only guaranteed to work reliably when using a local disk file system.</p>
</blockquote>
<h1 id="配置日志库服务">配置日志库服务</h1><p>我们希望日志库能够根据用户需求，把log打印到控制台、或者输出到SD卡的文件，或者在某些条件下把SD的日志文件上传到服务器，那么就需要以service的形式来提供日志库的功能。</p>
<p>大体的架构设计，就是把日志库service跑在一个独立的进程中，提供一个wrapper类供用户调用，对于日志库servcie的任何调用都对用户是透明的，用户只需要像使用android自带的Log工具那样使用.d()、.e()方法就可以了。每个app在自己的Application类中调用日志库wrappe类的初始化函数，在这一步传入app自己的相关信息如包名等，日志库会根据包名生成对应的日志文件。service中开一个新线程，里面显示地启动一个looper，外界发来的打印log的请求都被以消息的形式传递给这个新线程的消息队列来处理。</p>
<p>Thread的run方法大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Log.VERBOSE:</span><br><span class="line">                        printToFile(msg, <span class="string">"VERBOSE"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Log.DEBUG:</span><br><span class="line">                        printToFile(msg, <span class="string">"DEBUG"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Log.INFO:</span><br><span class="line">                        printToFile(msg, <span class="string">"INFO"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Log.WARN:</span><br><span class="line">                        printToFile(msg, <span class="string">"WARN"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Log.ERROR:</span><br><span class="line">                        printToFile(msg, <span class="string">"ERROR"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Log.ASSERT:</span><br><span class="line">                        printToFile(msg, <span class="string">"ASSERT"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始servcie的工作线程是在orhanobut/logger之上做扩展，对于wrapper类的实现是使用AIDL，在app调用wrapper的初始化函数时，wrapper自动bind到日志库service，然后再通过AIDL调用service的初始化以及打印log的方法（这些对用户app都是透明的）。这里就遇到一个大坑：</p>
<p>如果以显示Intent的方法来启动servcie，就会发现把日志库以module源码的形式提供给app使用是没有问题的，但是如果打成aar包提供给app使用，就会出现bind失败，很奇怪。</p>
<p>如果以隐式Intent的方法来启动service，打成aar包也可以正常启动servie，但是由于android 5.0以上要求必须以显示Intent启动service，故这种方法的覆盖范围太小。</p>
<p>后来大神review了我的代码，说最好不要用AIDL，因为那样会一直在app和servcie之间保持一个长连接，没有必要。可以直接用start方法启动servcie，用intent来传递请求参数，也是一样的。再加上我写的第一版是以log4j的形式，虽然提供了gradle的参数配置日志库的各项功能，但是功能是写死的，无法扩展，如果用户有一些个性化的日志需求就没法用我这个东西。</p>
<p>所以后来就对代码进行了重构，改为在JakeWharton/timber之上扩展，我提供一个日志框架，以及两个日志工具（打印到控制台、打印到文件），用户也可以继承我的日志工具基类实现自己的日志工具。用户在自己的app中，根据业务需求，在初始化时选择一个或多个日志工具安装到框架，具体的打印请求也是同android默认日志工具一样直接.d()、.e()这样调用，很方便。</p>
<p>这里记一下踩到的另外几个坑，有些比较低级😓：<br>1、一开始之所以选择在orhanobut/logger上扩展，是因为它默认提供了非常美观的打印格式，以及线程信息、日志调用栈信息。后来突然反应过来，我提供的库虽然会与用户app打进同一个apk，wrapper也是与用户app跑在同一线程，但是真正的日志打印工作是在service的单独进程中完成的，那么它默认提供的调用栈信息就无意义了。  </p>
<p>2、ADIL是同步调用，而service的所有其它接口（bind, unbind, startService, stopService）都是异步接口，立即返回。参考：<a href="http://blog.csdn.net/edisonlg/article/details/7164761）。" target="_blank" rel="external">http://blog.csdn.net/edisonlg/article/details/7164761）。</a>  </p>
<p>3、在调试时发现初始化貌似很耗时，跟踪了一下，发现new FileHandler()这一操作居然要耗时30~40ms!!!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="调研">调研</h1><p>在android开发中，如果需要打印调试信息，往往会使用Log.d()、Log.e()之类的由android.util.Log提供的方法。它的好处是简单、方便，不足也很明显，可定制性差，不能打印到文件。如果想在发行版app中的某些关键语句打印log到文件，或者在app崩溃时把崩溃信息打印到文件供上传分析，那么android.util.Log就无能为力了。<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.carrotsight.com/tags/Android/"/>
    
      <category term="库项目" scheme="http://www.carrotsight.com/tags/%E5%BA%93%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="日志" scheme="http://www.carrotsight.com/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="Android" scheme="http://www.carrotsight.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FlatBuffers学习总结]]></title>
    <link href="http://www.carrotsight.com/2015/10/10/FlatBuffers%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html"/>
    <id>http://www.carrotsight.com/2015/10/10/FlatBuffers学习总结.html</id>
    <published>2015-10-10T13:37:08.000Z</published>
    <updated>2015-12-03T08:41:07.000Z</updated>
    <content type="html"><![CDATA[<p>据说facebook使用google的黑科技flatbuffers，用来替代传统的json进行数据交换，大大提高了facebook android客户端的效率。于是我在网上查找各种资料学习了一下flatbuffers，参看资料包括GOOGLE官方文档、facebook技术博客、以及其他国内的个人博客，也写了些代码做实验，以此文作为学习总结。</p>
<h2 id="什么是Google_FlatBuffers">什么是Google FlatBuffers</h2><p>FlatBuffers是一个开源的、跨平台的、高效的、提供了C++/Java接口的序列化工具库。它是Google专门为游戏开发或其他性能敏感的应用程序需求而创建。尤其更适用于移动平台，这些平台上内存大小及带宽相比桌面系统都是受限的，而应用程序比如游戏又有更高的性能要求。它将序列化数据存储在缓存中，这些数据既可以存储在文件中，又可以通过网络原样传输，而不需要任何解析开销。<br><a id="more"></a></p>
<h2 id="为什么要使用Google_FlatBuffers">为什么要使用Google FlatBuffers</h2><ol>
<li>对序列化数据的访问不需要打包和拆包——它将序列化数据存储在缓存中，这些数据既可以存储在文件中，又可以通过网络原样传输，而没有任何解析开销；  </li>
<li>内存效率和速度——访问数据时的唯一内存需求就是缓冲区，不需要额外的内存分配；   </li>
<li>扩展性、灵活性——它支持的可选字段意味着不仅能获得很好的前向/后向兼容性（对于长生命周期的游戏来说尤其重要，因为不需要每个新版本都更新所有数据）；  </li>
<li>最小代码依赖——仅仅需要自动生成的少量代码和一个单一的头文件依赖，很容易集成到现有系统中。  </li>
<li>强类型设计——尽可能使错误出现在编译期，而不是等到运行期才手动检查和修正；</li>
<li>使用简单——生成的C++代码提供了简单的访问和构造接口；而且如果需要，通过一个可选功能可以用来在运行时高效解析Schema和类JSON格式的文本；</li>
<li>跨平台——支持C++11、Java，而不需要任何依赖库；在最新的gcc、clang、vs2010等编译器上工作良好。  </li>
</ol>
<p>官网的基准测试结果如下图所示：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/屏幕快照%202015-09-30%20下午3.08.24.png" alt=""></p>
<h2 id="为什么不使用Protocol_Buffers或者JSON">为什么不使用Protocol Buffers或者JSON</h2><h3 id="Protocol_Buffers_vs_FlatBuffers">Protocol Buffers vs FlatBuffers</h3><p>Protocol Buffers的确和FlatBuffers比较类似，但其主要区别在于FlatBuffers在访问数据前不需要解析/拆包这一步，而且Protocol Buffers没有可选的文本导入/导出功能（FlatBuffers可以直接根据Schema和json文本生成对应的二进制数据文件）。<br>Protocol Buffers使用一些特殊的数据结构来存储数据，从而在解析数据时需要花费额外的时间。比如，使用varints来存储整型数，varints是一种使用一个或多个字节来序列化整型数的方法，越小的数占用的字节数就越少。同时，代表一个数字的多个字节采用little endian的方式来存储。这就导致在解析数据时，需要判断哪几个字节是表示这个字段的，并进行其他的数学变换来还原出原始数据。<br>关于protocal buffers具体的数据编码方式，可以参考<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="external">google开发者网站</a>以及<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-gpb/" target="_blank" rel="external">IBM技术博客</a>。  </p>
<p>与之相对，FlatBuffers可以直接根据起始位置+偏移量直接获取到数据，无解析过程，效率更高，而伴随的副作用是FlatBuffers需要占用相对更多的空间，因为Protocol Buffers的编码在一定程度上压缩了数据。</p>
<p>网上有人进行了性能对比试验，结果如下图：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-10-10/60479922.jpg" alt=""></p>
<h3 id="JSON_vs_FlatBuffers">JSON vs FlatBuffers</h3><p>JSON是非常可读的，而且当和动态类型语言（如JavaScript）一起使用时非常方便。然而在静态类型语言中序列化数据时，JSON不但具有运行效率低的明显缺点，而且会让你写更多的代码来访问数据（这个与直觉相反）。</p>
<h2 id="哪些项目使用了FlatBuffers">哪些项目使用了FlatBuffers</h2><ul>
<li><strong>Cocos2d-x</strong>, the #1 open source mobile game engine, uses it to serialize all their game data.</li>
<li><strong>Facebook</strong> uses it for client-server communication in their Android app. They have a nice article explaining how it speeds up loading their posts.</li>
<li><strong>Fun Propulsion Labs</strong> at Google uses it extensively in all their libraries and games.</li>
</ul>
<h2 id="FlatBuffers原理">FlatBuffers原理</h2><p>假设我们有一个person类，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> friendshipStatus;</span><br><span class="line">    Person spouse;</span><br><span class="line">    List&lt;Person&gt;friends;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的spouse和friends字段页包含了person对象，这样就形成了一个树结构。下面就是关于此对象在FlatBuffer中存储的简化图示：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-10-8/13378046.jpg" alt=""></p>
<p>从图中可以看到：</p>
<ul>
<li>每个对象都被分成两部分：中心点左边的元数据部分（或者叫vtable），和中心点右边的真实数据部分。</li>
<li>每个字段都对应vtable中的一个槽（slot），它存储了那个字段的真实数据的偏移量。例如，John的vtable的第一个槽的值是1，表明John的名字被存储在John的中心点右边的一个字节的位置上。</li>
<li>如果一个字段是一个对象，那么它在vtable中的偏移量会指向子对象的中心点（pivot point）。比如，John的vtable中第三个槽指向Mary的中心点。</li>
<li>要表明某个字段现在没有数据，可以在vtable对应的槽中使用偏移量0来标注。</li>
</ul>
<p>要了解更复杂的关于FlatBuffers字段修改的实现原理，可以查看<a href="https://code.facebook.com/posts/872547912839369/improving-facebook-s-performance-on-android-with-flatbuffers/" target="_blank" rel="external">facebook的文档</a>中的“Mutation on FlatBuffers”部分。</p>
<h2 id="简明使用步骤">简明使用步骤</h2><ol>
<li>编写一个用来定义你想序列化的数据的schema文件（又称IDL），数据类型可以是各种大小的int、float，或者是string、array，或者另一对象的引用，甚至是对象集合。各个数据属性都是可选的，且可以设置默认值,所以不必要为每个对象实例都去呈现这些字段。  </li>
<li>使用FlatBuffer编译器flatc生成C++头文件或者Java类，生成的代码里额外提供了访问、构造序列化数据的辅助类。生成的代码仅仅依赖flatbuffers.h；  </li>
<li>使用FlatBufferBuilder类构造一个二进制buffer。你可以向这个buffer里循环添加各种对象，而且很简单，就是一个单一函数调用；</li>
<li>保存或者发送该buffer；</li>
<li>当再次读取该buffer时，你可以得到这个buffer根对象的指针，然后就可以简单的就地读取数据内容。</li>
</ol>
<h2 id="FlatBuffers使用实战">FlatBuffers使用实战</h2><h3 id="构建flatc(FlatBuffers编译器)">构建flatc(FlatBuffers编译器)</h3><p>从<a href="https://github.com/google/flatbuffers" target="_blank" rel="external">Google的flatbuffers仓库</a>下载或克隆源代码,可以在<a href="https://google.github.io/flatbuffers/md__building.html" target="_blank" rel="external">Google的FlatBuffers构建文档中</a>查看构建过程。如果你是Mac用户的话就可以直接按照下面的步骤来操作：  </p>
<ol>
<li>打开下载的源代码，目录是<code>\{extract directory}\build\Xcode\FlatBuffers.xcodeproj</code> ，用Xcode打开此文件。   </li>
<li>点击<code>Play</code>按钮或者<code>⌘ + R</code>运行。  </li>
<li>flatc可执行文件会出现在项目的根目录下。<br>现在就可以使用flatc来从给定的schema生成模型类，或者把JSON转换成FlatBuffers二进制文件了。</li>
</ol>
<h3 id="编写一个Schema">编写一个Schema</h3><p>Schema语言（即IDL）的语法与C语言家族很类似。一个简单的例子如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example IDL file</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyGame;</span><br><span class="line"></span><br><span class="line">attribute <span class="string">"priority"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color : byte &#123; Red = <span class="number">1</span>, Green, Blue &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> Any &#123; Monster, Weapon, Pickup &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Vec3 &#123;</span><br><span class="line">  x:<span class="keyword">float</span>;</span><br><span class="line">  y:<span class="keyword">float</span>;</span><br><span class="line">  z:<span class="keyword">float</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table Monster &#123;</span><br><span class="line">  pos:Vec3;</span><br><span class="line">  mana:<span class="keyword">short</span> = <span class="number">150</span>;</span><br><span class="line">  hp:<span class="keyword">short</span> = <span class="number">100</span>;</span><br><span class="line">  name:<span class="built_in">string</span>;</span><br><span class="line">  friendly:<span class="keyword">bool</span> = <span class="literal">false</span> (deprecated, priority: <span class="number">1</span>);</span><br><span class="line">  inventory:[ubyte];</span><br><span class="line">  color:Color = Blue;</span><br><span class="line">  test:Any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root_type Monster;</span><br></pre></td></tr></table></figure>
<p>（Weapon 和 Pickup没有在这个例子中列出。）</p>
<h4 id="Tables">Tables</h4><p>Tables是在FlatBuffers中定义对象的主要方式，由名字（这里的Monster）和字段列表组成。每一个字段都有名字、类型、和一个可选的默认值（如果忽略的话，默认是0/NULL）。<br><strong>每一个字段都是可选的</strong>：对每一个单独的对象个体，你都可以选择忽略一些字段。也就使你可以灵活的增加字段，而不必担心数据膨胀。这个设计也是FlatBuffers向前和向后兼容的机制。<br><strong>注意：</strong>  </p>
<ul>
<li>如果要在schema中添加新字段，只能在table的末尾进行添加。</li>
<li>如果你不再使用某些字段了，你不能从schema中删除它们。你可以不再把它们写入到你的数据中，效果是一样的。  </li>
</ul>
<h4 id="Structs">Structs</h4><p>Structs与Table类似，只不过没有字段是可选的了(所以没有默认值了)，并且字段不能增加或被废弃（deprecated）。Struct只能包含标量或者其他struct。如果你<strong>非常确定</strong>任何变化都不会发生，那么就可以使用struct。Struct使用的内存比table少，并且读取时比table更快（它们通常被以in-line的方式存储在它们的父对象中，并且不适用virtual table）。</p>
<h4 id="类型">类型</h4><p>内建的标量类型：  </p>
<blockquote>
<ul>
<li>8 bit: byte ubyte bool</li>
<li>16 bit: short ushort</li>
<li>32 bit: int uint float</li>
<li>64 bit: long ulong double</li>
</ul>
</blockquote>
<p>内建的非标量类型：  </p>
<blockquote>
<ul>
<li>关于任何其他类型的Vector</li>
<li>string，只能存储UTF-8或者7-bit ASCII。如果需要存储其他编码的文本，或者通用二进制数据，请使用vector（[byte]或者[ubyte]）。</li>
<li>对其他table、struct、enum或者union的引用。</li>
</ul>
</blockquote>
<p>关于编写Schema的更多信息，可以参考<a href="https://google.github.io/flatbuffers/md__schemas.html" target="_blank" rel="external">Google文档：Writing a aschema</a>。</p>
<p>在实验中，我直接使用网上的示例文件。<br>要处理的数据对应的JSON文件的下载地址为：<a href="https://github.com/frogermcs/FlatBuffs/blob/master/flatbuffers/repos_json.json" target="_blank" rel="external">https://github.com/frogermcs/FlatBuffs/blob/master/flatbuffers/repos_json.json</a>    </p>
<p>这个JSON的结构如下面的片段所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "repos": [</span><br><span class="line">    &#123;</span><br><span class="line">      "id": 27149168,</span><br><span class="line">      "name": "acai",</span><br><span class="line">      "full_name": "google/acai",</span><br><span class="line">      "owner": &#123;</span><br><span class="line">        "login": "google",</span><br><span class="line">        "id": 1342004,</span><br><span class="line">        ...</span><br><span class="line">        "type": "Organization",</span><br><span class="line">        "site_admin": false</span><br><span class="line">      &#125;,</span><br><span class="line">      "private": false,</span><br><span class="line">      "html_url": "https://github.com/google/acai",</span><br><span class="line">      "description": "Testing library for JUnit4 and Guice.",</span><br><span class="line">      ...</span><br><span class="line">      "watchers": 21,</span><br><span class="line">      "default_branch": "master"</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用FlatBuffers处理这个JSON数据，我们需要编写对应的Schema，在这个例子中需要创建3个Table：<code>ReposList</code>, <code>Repo</code> 和 <code>User</code>，还要定义<code>root_type</code>。  </p>
<p>可以直接从github下载已经编写好的Schema，地址为<a href="https://github.com/frogermcs/FlatBuffs/blob/master/flatbuffers/repos_schema.fbs" target="_blank" rel="external">https://github.com/frogermcs/FlatBuffs/blob/master/flatbuffers/repos_schema.fbs</a>。<br>这个Schema的部分片段如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">table ReposList &#123;</span><br><span class="line">    repos : [Repo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table Repo &#123;</span><br><span class="line">    id : <span class="keyword">long</span>;</span><br><span class="line">    name : <span class="built_in">string</span>;</span><br><span class="line">    full_name : <span class="built_in">string</span>;</span><br><span class="line">    owner : User;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    labels_url : <span class="built_in">string</span> (deprecated);</span><br><span class="line">    releases_url : <span class="built_in">string</span> (deprecated);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table User &#123;</span><br><span class="line">    login : <span class="built_in">string</span>;</span><br><span class="line">    id : <span class="keyword">long</span>;</span><br><span class="line">    avatar_url : <span class="built_in">string</span>;</span><br><span class="line">    gravatar_id : <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    site_admin : <span class="keyword">bool</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root_type ReposList;</span><br></pre></td></tr></table></figure>
<h3 id="FlatBuffers数据文件">FlatBuffers数据文件</h3><p>现在我们要做的就是把JSON文件转换成FlatBuffers二进制文件，并且生成能够以JAVA友好方式表达我们的数据的JAVA模型。方法是在中断中执行以下命令：<br><code>$ ./flatc -j -b repos_schema.fbs repos_json.json</code></p>
<p>如果一切运行正常，会看到一系列新生成的文件，它们分别是：</p>
<ul>
<li>repos_json.bin (我们把它重命名为repos_flat.bin)</li>
<li>Repos/Repo.java</li>
<li>Repos/ReposList.java</li>
<li>Repos/User.java</li>
</ul>
<p>Schema编译器(即flatc)的完整使用方法为：  </p>
<blockquote>
<p>flatc [ -c ] [ -j ] [ -b ] [ -t ] [ -o PATH ] [ -I PATH ] [ -S ] FILES…<br>      [ – FILES…]  </p>
</blockquote>
<p>具体参数说明可以在<a href="https://google.github.io/flatbuffers/md__compiler.html" target="_blank" rel="external">Google说明文档</a>查看。</p>
<h3 id="在Android_app中读数据">在Android app中读数据</h3><p>在Android Studio中使用FlatBuffers，需要把repos_flat.bin放到res/raw/目录下，同时把<code>repo.java</code>, <code>ReposList.java</code> 和 <code>User.java</code>放到工程源代码的某个目录下。  </p>
<p>FlatBuffers提供java库来直接在java中操纵这种数据格式。从<a href="https://github.com/frogermcs/FlatBuffs/blob/master/app/libs/flatbuffers-java-1.2.0-SNAPSHOT.jar" target="_blank" rel="external">这里</a>下载jar文件（也可以自己下载的latBuffers源代码，用mvn生成这个库文件），把它放在Android工程的app/libs/目录下。  </p>
<p>在需要读取FlatBuffers数据的地方，先把bin文件读取到一个byte数组中，然后用如下所示的代码访问各数据字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer bb = ByteBuffer.wrap(dataByteArray);</span><br><span class="line">ReposList rootRoposList = ReposList.getRootAsReposList(bb);</span><br><span class="line">Log.i(<span class="string">"TAG"</span>, <span class="string">"reposLength = "</span> + rootRoposList.reposLength());</span><br><span class="line">Repo repo1 = rootRoposList.repos(<span class="number">0</span>);</span><br><span class="line">Log.i(<span class="string">"TAG"</span>, <span class="string">"id: "</span> + repo1.id() + <span class="string">"\nname: "</span> + repo1.name() + <span class="string">"\nforks: "</span> + repo1.forks());</span><br></pre></td></tr></table></figure>
<p>第一行代码中传入的参数dataByteArray就是从bin文件读出的二进制byte数组。</p>
<p><em>注意：</em><br>Java不支持无符号标量。这意味着你在schema中使用的任何无符号类型实际上都会被表达成为一个有符号的值。这表明，所有的bit都仍然在，但可能代表一个负数。比如，要把一个<code>byte b</code>作为一个无符号数来读取，可以这样做：<code>(short)(b &amp; 0xFF)</code>。</p>
<h3 id="在Android_app中写数据（以FlatBuffers格式传输数据）">在Android app中写数据（以FlatBuffers格式传输数据）</h3><p>先创建Builder：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlatBufferBuilder fbb = <span class="keyword">new</span> FlatBufferBuilder();</span><br></pre></td></tr></table></figure>
<p>创建String字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> str = fbb.createString(<span class="string">"MyMonster"</span>);</span><br></pre></td></tr></table></figure>
<p>创建一个包含struct的table：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Monster.startMonster(fbb);</span><br><span class="line">Monster.addPos(fbb, Vec3.createVec3(fbb, <span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">3.0</span>, (<span class="keyword">byte</span>)<span class="number">4</span>, (<span class="keyword">short</span>)<span class="number">5</span>, (<span class="keyword">byte</span>)<span class="number">6</span>));</span><br><span class="line">Monster.addHp(fbb, (<span class="keyword">short</span>)<span class="number">80</span>);</span><br><span class="line">Monster.addName(fbb, str);</span><br><span class="line">Monster.addInventory(fbb, inv);</span><br><span class="line">Monster.addTest_type(fbb, (<span class="keyword">byte</span>)<span class="number">1</span>);</span><br><span class="line">Monster.addTest(fbb, mon2);</span><br><span class="line">Monster.addTest4(fbb, test4s);</span><br><span class="line"><span class="keyword">int</span> mon = Monster.endMonster(fbb);</span><br></pre></td></tr></table></figure>
<p>最后，需要终止这个buffer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Monster.finishMonsterBuffer(fbb, mon);</span><br></pre></td></tr></table></figure>
<p>这个buffer现在已经可以被传输了。它被包含在ByteBuffer中，可以通过fbb.dataBuffer()来获取。很重要的一点是，buffer中有效的数据不是从偏移量0开始的，而是从fbb.dataBuffer().position()开始的，在fbb.dataBuffer().capacity()结束。</p>
<p>更详细的java使用方法，可以参见<a href="https://google.github.io/flatbuffers/md__java_usage.html" target="_blank" rel="external">google官方文档</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>据说facebook使用google的黑科技flatbuffers，用来替代传统的json进行数据交换，大大提高了facebook android客户端的效率。于是我在网上查找各种资料学习了一下flatbuffers，参看资料包括GOOGLE官方文档、facebook技术博客、以及其他国内的个人博客，也写了些代码做实验，以此文作为学习总结。</p>
<h2 id="什么是Google_FlatBuffers">什么是Google FlatBuffers</h2><p>FlatBuffers是一个开源的、跨平台的、高效的、提供了C++/Java接口的序列化工具库。它是Google专门为游戏开发或其他性能敏感的应用程序需求而创建。尤其更适用于移动平台，这些平台上内存大小及带宽相比桌面系统都是受限的，而应用程序比如游戏又有更高的性能要求。它将序列化数据存储在缓存中，这些数据既可以存储在文件中，又可以通过网络原样传输，而不需要任何解析开销。<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.carrotsight.com/tags/Android/"/>
    
      <category term="FlatBuffers" scheme="http://www.carrotsight.com/tags/FlatBuffers/"/>
    
      <category term="Google" scheme="http://www.carrotsight.com/tags/Google/"/>
    
      <category term="facebook" scheme="http://www.carrotsight.com/tags/facebook/"/>
    
      <category term="Android" scheme="http://www.carrotsight.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android编程要注意的安全规范]]></title>
    <link href="http://www.carrotsight.com/2015/09/19/2015-9-19-Android%E7%BC%96%E7%A8%8B%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%AE%89%E5%85%A8%E8%A7%84%E8%8C%83.html"/>
    <id>http://www.carrotsight.com/2015/09/19/2015-9-19-Android编程要注意的安全规范.html</id>
    <published>2015-09-19T11:46:08.000Z</published>
    <updated>2015-12-03T08:08:03.000Z</updated>
    <content type="html"><![CDATA[<p>这两天阅读了一下android developer网站与安全相关的部分，对android编程过程中主要注意的安全细节进行了学习，在此总结一下要点。</p>
<h2 id="Android框架自身的安全性机制">Android框架自身的安全性机制</h2><ol>
<li>Android应用程序沙盒，把每个app的数据与代码都分隔开。  </li>
<li>对各种安全功能进行了强健实现的应用程序框架，如密码学、权限、安全IPC等。  </li>
<li>加密的文件系统，它能够保护丢失或被盗设备的数据。  </li>
<li>用户能够授权权限来限制对系统和用户数据的访问。  </li>
<li>应用程序定义的权限。<a id="more"></a>
<h2 id="数据存储">数据存储</h2><h3 id="使用内部存储">使用内部存储</h3></li>
<li>默认情况下，你在内部存储上创建的文件只能被该app本身访问。  </li>
<li>应该尽量避免在IPC文件上使用 MODE_WORLD_WRITEABLE或MODE_WORLD_READABLE模式。如果实在需要数据共享，应该使用content provider。  </li>
<li>对于敏感数据，应该选择一个密钥对本地文件进行加密，这个密钥应该不能直接被应用程序访问。比如，把密钥保存在KeyStore中，并且用一个不存储在该设备上的用户密码来保护它。</li>
</ol>
<h3 id="使用扩展存储">使用扩展存储</h3><ol>
<li>扩展存储（如SD卡）上的文件是全局可读写的（被其他应用程序）。不要在扩展存储上存放敏感信息。  </li>
<li>处理扩展存储上的数据前最好进行输入验证。</li>
</ol>
<h3 id="使用content_providers">使用content providers</h3><ol>
<li>如果不打算让其他应用程序访问你的ContentProvider，就在manifest文件中用<code>android:exported=false</code>来标记它。  </li>
<li>如果创建的ContentProvider需要被提供给其他应用程序使用，可以特别指定单独的读权限和写权限。  </li>
<li>如果使用ContentProvider只是在你自己的几个app之间共享数据，那么最好把<code>android:protectionLevel</code>属性设置为<code>&quot;signature&quot;</code>。  </li>
<li>可以对content provider提供更细粒度的访问控制，如使用<code>android:grantUriPermissions</code>属性，在Intent对象中使用<code>FLAG_GRANT_READ_URI_PERMISSION</code>和<code>FLAG_GRANT_WRITE_URI_PERMISSION</code>标记。  </li>
<li>在访问content provider时，使用参数化查询方法如query()、update()、delete()等来避免潜在的SQL注入风险。但这仍有风险，比如selection参数是通过之前用户提交的数据连接而成的。  </li>
<li>不要对写权限的安全性产生错觉。比如，如果写权限允许写SQL语句，那么WHERE字句巧妙地构造就可以使得“写权限”等价于“读写权限”。</li>
</ol>
<h2 id="使用权限">使用权限</h2><h3 id="请求权限">请求权限</h3><ol>
<li>请求最少数量的权限，如果一个权限对你的app来说不是必须的，就不要请求。  </li>
<li>完全有可能用一种方法不请求任何权限，比如为了创建独一无二的标示符可以使用GUID而不是请求设备信息，可以把数据存储在内部存储（无须权限）而不是存储在扩展存储（需要权限）。  </li>
<li>推荐尽可能使用访问控制，而不是用户确认的权限，因为权限可能让用户疑惑。</li>
<li>不要泄露有权限保护的数据。</li>
</ol>
<h3 id="创建权限">创建权限</h3><p>这种情况很少见，因为系统定义的权限已近覆盖了大部分的需求。<br>如果必须创建新权限，考虑是否可以用<code>&quot;signature&quot;</code>级别的<code>protection level</code>来实现。</p>
<h2 id="使用网络">使用网络</h2><h3 id="使用IP网络">使用IP网络</h3><ol>
<li>确保对于敏感信息使用合适的协议，比如HttpsURLConnection。如果服务器支持的话，我们更倾向于使用HTTPS而不是HTTP，因为移动设备频繁的连接在不安全的网络中，比如公共Wi-Fi热点。  </li>
<li>认证的加密的套接字级别的会话，可以很容易地用SSLSocket类来实现。  </li>
<li>有些引用程序使用localhost网络端口来处理敏感的IPC，这种做法应该避免，因为其他应用程序也能够访问到这些接口。应该使用具有授权控制的Android IPC机制比如Service。</li>
<li>所有通过HTTP协议或其他不安全协议获取到的数据都是不可信任的，要做好数据验证工作。</li>
</ol>
<h3 id="使用电话网络">使用电话网络</h3><p>SMS协议的设计本就不适合app传输数据。不管是在网络上还是设备上，SMS既没有加密也没有强壮的认证。在Android设备上，SMS消息是以广播形式传输的，所以它们可以被所有其他具有<code>READ_SMS</code>权限的应用程序读取或捕获。  </p>
<h2 id="使用WebView">使用WebView</h2><ol>
<li>如果你的应用程序不直接通过webview使用JavaScript，那么就不要调用<code>setJavaScriptEnabled()</code>。默认情况下webview是不执行JavaScript的，这样就可以防止跨站脚本攻击。  </li>
<li>只把<code>addJavaScriptInterface()</code>暴露给具有可信输入的网页。  </li>
<li>如果你的应用程序通过WebView访问敏感数据，你可以使用    <code>clearCache()</code>方法来删除任何存储在本地的文件。也可以使用服务器端的header比如<code>no-cache</code>来表明一个应用程序不应该缓存特定的内容。</li>
<li>用户名和密码不应该存储在设备上。初次认证的时候使用用户提供的用户名和密码，以后就使用一个短生命周期的、service特有的认证token。</li>
<li>被多个应用程序访问的Service应该使用AccountManager来访问。</li>
</ol>
<h2 id="使用密码学">使用密码学</h2><ol>
<li>如果需要安全地从已知位置获取一个文件，可以很简单地使用<code>HTTPS URI</code>。  </li>
<li>如果需要安全数据通道，考虑使用<code>HttpsURLConnection</code>或者<code>SSLSocket</code>，而不是去写一个你自己的协议。  </li>
<li>如果你真的需要实现自己的协议，也不要自己实现加密算法，可以直接只用存在的已实现的加密算法，比如<code>Cipher</code>类中的AES或者RSA算法。  </li>
<li>使用安全随机数生成器<code>SecureRandom</code>来初始化任何的密钥、<code>KeyGenerator</code>。使用非安全随机数生成器得到的密钥，会削弱算法的安全强度，也会导致离线攻击。</li>
<li>如果需要存储一个密钥来提供多次使用，应该使用诸如<code>KeyStore</code>之类的机制。  </li>
</ol>
<h2 id="使用IPC">使用IPC</h2><ol>
<li>不要使用传统Linux中的IPC技术比如网络套接字和共享文件等。应该使用Android系统提供的IPC功能比如Intent、与Service配合的Binder或者Messenger、BroadcastReceiver。Android的IPC机制允许你验证连接到你IPC的应用程序的身份，并且能够为每个IPC机制设置安全策略。  </li>
<li>如果你的IPC机制不打算给其他应用程序使用，可以在manifest清单中把<code>android:exported</code>属性设置为<code>false</code>。  </li>
</ol>
<hr>
<p>其他安全性相关问题，可以参考:<br>1、<a href="http://developer.android.com/training/best-security.html" target="_blank" rel="external">http://developer.android.com/training/best-security.html</a><br>2、<a href="https://www.owasp.org/index.php/OWASP_Mobile_Security_Project#tab=Secure_Mobile_Development" target="_blank" rel="external">https://www.owasp.org/index.php/OWASP_Mobile_Security_Project#tab=Secure_Mobile_Development</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两天阅读了一下android developer网站与安全相关的部分，对android编程过程中主要注意的安全细节进行了学习，在此总结一下要点。</p>
<h2 id="Android框架自身的安全性机制">Android框架自身的安全性机制</h2><ol>
<li>Android应用程序沙盒，把每个app的数据与代码都分隔开。  </li>
<li>对各种安全功能进行了强健实现的应用程序框架，如密码学、权限、安全IPC等。  </li>
<li>加密的文件系统，它能够保护丢失或被盗设备的数据。  </li>
<li>用户能够授权权限来限制对系统和用户数据的访问。  </li>
<li>应用程序定义的权限。]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.carrotsight.com/tags/Android/"/>
    
      <category term="安全" scheme="http://www.carrotsight.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="Android" scheme="http://www.carrotsight.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Think in Java》类型信息 – 学习笔记]]></title>
    <link href="http://www.carrotsight.com/2015/09/16/2015-9-16-%E3%80%8AThink-in-Java%E3%80%8B%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF-%E2%80%93-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://www.carrotsight.com/2015/09/16/2015-9-16-《Think-in-Java》类型信息-–-学习笔记.html</id>
    <published>2015-09-16T08:22:16.000Z</published>
    <updated>2015-12-03T08:07:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Class对象">Class对象</h2><p>Class对象是一种特殊的对象，它包含了与类有关的信息。Class对象用来创建类的所有的“常规”对象。Java使用Class对象来执行RTTI（包括类型转换操作）。<br>每当编写并编译一个新类，就会产生一个Class对象（或者说被保存在一个同名的.class文件中）。  </p>
<p>Class对象的引用可以通过Class.forName()或普通对象的getClass()方法来获取,或类名加上.class来获得。其中，getClass()方法属于根类Object的一部分。”.class”称为<em>类字面常量</em>，他在编译时就会受到检查，所以更安全，也更高效。  </p>
<p>差别：“.class”不会引起类的初始化，而Class.forName()方法会立即就进行初始化。<br><a id="more"></a><br>Class对象包含很多有用的方法，能够了解一个类型的所有信息，比如：  </p>
<ol>
<li>getName（）：产生全限定的类名  </li>
<li>getSimpleName（）：产生不含包名的类名  </li>
<li>getCanonicalName（）：产生全限定的类名  </li>
<li>isInterface（）：判定这个Class对象是否表示某个接口  </li>
<li>getSuperclass（）：查询直接基类```</li>
</ol>
<p>如果调用Class对象的newInstance（）方法来实例化一个类，则这个类必须带有默认构造器。  </p>
<p>为了使用类而做的准备工作实际包含3个步骤：  </p>
<ol>
<li><strong>加载</strong>。这是由类加载器执行的。该步骤查找字节码并从这些字节码中创建一个Class对象。  </li>
<li><strong>链接</strong>。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必要的话，将解析这个类创建的对其他类的所有引用。  </li>
<li><strong>初始化</strong>。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。  </li>
</ol>
<h2 id="反射：运行时的类信息">反射：运行时的类信息</h2><p>RTTI和反射之间真正的区别只在于，对RTTI来说，编译器在<strong>编译时</strong>打开和检查.class文件（即我们可以用“普通”方式调用对象的所有方法）。而对于反射机制来说，.class文件在编译时是不可获取的，所以是在<strong>运行时</strong>打开和检查.class文件。  </p>
<p>Class类与java.lang.reflect类库一起对<em>反射</em>的概念进行了支撑，该类库包含了Field、Method以及Constructor类（每个类都实现了Member接口）。这些类型的对象是由JVM在运行时创建的，用以表示未知类里对应的成员。这样就可以使用Constructor创建新的对象，用get()和set()方法读取和修改与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。另外，还可以调用getField()、getMethods()和getConstructors()等很便利的方法，以返回表示字段、方法以及构造器的对象的数组。这样，<strong>匿名对象的类信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。</strong>  </p>
<p>用如下代码来测试反射机制： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class&lt;?&gt; appleClass = Class.forName(<span class="string">"classinfo.Apple"</span>);</span><br><span class="line">			System.out.println(<span class="string">"===Methods:===\n"</span>);</span><br><span class="line">			<span class="keyword">for</span>( Method method : appleClass.getMethods())&#123;</span><br><span class="line">				System.out.println(method.toString());</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"===Constructors:===\n"</span>);</span><br><span class="line">			<span class="keyword">for</span>( Constructor&lt;?&gt; cons : appleClass.getConstructors())&#123;</span><br><span class="line">				System.out.println(cons.toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">	<span class="keyword">private</span> String color;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(<span class="keyword">int</span> weight, String color)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.weight = weight;</span><br><span class="line">		<span class="keyword">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">incWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ++weight;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> --weight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为： </p>
<blockquote>
<p>===Methods:===<br>public int classinfo.Apple.incWeight()<br>public int classinfo.Apple.decWeight()<br>public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException<br>public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException<br>public final void java.lang.Object.wait() throws java.lang.InterruptedException<br>public boolean java.lang.Object.equals(java.lang.Object)<br>public java.lang.String java.lang.Object.toString()<br>public native int java.lang.Object.hashCode()<br>public final native java.lang.Class java.lang.Object.getClass()<br>public final native void java.lang.Object.notify()<br>public final native void java.lang.Object.notifyAll()</p>
<p>===Constructors:===<br>public classinfo.Apple()<br>public classinfo.Apple(int,java.lang.String)</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Class对象">Class对象</h2><p>Class对象是一种特殊的对象，它包含了与类有关的信息。Class对象用来创建类的所有的“常规”对象。Java使用Class对象来执行RTTI（包括类型转换操作）。<br>每当编写并编译一个新类，就会产生一个Class对象（或者说被保存在一个同名的.class文件中）。  </p>
<p>Class对象的引用可以通过Class.forName()或普通对象的getClass()方法来获取,或类名加上.class来获得。其中，getClass()方法属于根类Object的一部分。”.class”称为<em>类字面常量</em>，他在编译时就会受到检查，所以更安全，也更高效。  </p>
<p>差别：“.class”不会引起类的初始化，而Class.forName()方法会立即就进行初始化。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://www.carrotsight.com/tags/Java/"/>
    
      <category term="reflection" scheme="http://www.carrotsight.com/tags/reflection/"/>
    
      <category term="反射" scheme="http://www.carrotsight.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="Java" scheme="http://www.carrotsight.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Otto学习笔记]]></title>
    <link href="http://www.carrotsight.com/2015/09/15/2015-9-15-Otto%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://www.carrotsight.com/2015/09/15/2015-9-15-Otto学习笔记.html</id>
    <published>2015-09-15T07:49:16.000Z</published>
    <updated>2015-12-02T04:19:44.000Z</updated>
    <content type="html"><![CDATA[<p>在学习完EventBus后，发现与之类似的事件库还有otto，于是我也学习了一下。在网上找到的大部分博客其实都是对otto官方文档的中文翻译而已，对生产者的@Produce、PUBLISHING、PRODUCING之间的关系没有深入解释，也没有对EventBus的StickyEvnet与Otto中类似机制的对比，而这正是我想了解的。所以就自己写demo做了些实验，总结了这篇学习笔记。</p>
<p><strong><br>本文的Otto指的是：square/otto<br>EventBus指的是：greenrobot/EventBus<br>Github上有很多同名项目，不要搞错。
</strong></p>
<p>本文档前面是对Otto各方面的介绍。如果要学习快速使用，可以直接跳转到后面的<a href="#详细使用实例">详细使用实例</a>部分。</p>
<h2 id="特点">特点</h2><p>Otto的作用与EventBus类似，都是用于组件间通信，降低不同的类相互之间的耦合。如果不熟悉EventBus，可以先了解EventBus，下文涉及到otto与EventBus的对比。</p>
<p>Otto可以随便定义订阅者的消息处理函数的函数名，采用注解的方式来识别生产函数和消费函数（@Produce和@Subscribe），这是与EventBus明显的不同。<br><a id="more"></a></p>
<h2 id="PUBLISHING、SUBSCRIBING与PRODUCING">PUBLISHING、SUBSCRIBING与PRODUCING</h2><p>虽然同样是订阅者模式的实现，但是Otto与Eventbus相比，多了一个“PRODUCING”的概念（Eventbus中只有PUBLISHING和SUBSCRIBING的概念）。<br>其实这里的PRODUCING设计的初衷与Eventbus中的StickyEvent是相似的，都是为了能够取到某中类型的事件的最新值，但在实现上有较大差异。</p>
<h3 id="订阅事件">订阅事件</h3><p><strong>用来消耗（或者说处理）事件的是订阅者，必须用@Subscribe标注。</strong>  订阅者（假定是一个Activity）需要在初始化时（onCreate()方法或onResume()方法中）使用register（）方法向总线注册，在onDestroy（）或onPause（）时调用unregister（）从总线反注册。  </p>
<h3 id="发布事件">发布事件</h3><h4 id="PUBLISHING">PUBLISHING</h4><p>而产生（或者说发布）事件的方式有两种，一种是不使用@Produce标注，这种方式被otto官方文档称为<strong>PUBLISHING</strong>，方法是直接调用bus对象的post方法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyApplicationUtil.bus.post(<span class="keyword">new</span> TextEvent(<span class="string">"这是PUBLISHING事件: "</span> + <span class="keyword">new</span> Date()));</span><br></pre></td></tr></table></figure>   </p>
<h4 id="PRODUCING">PRODUCING</h4><p>另一种是使用@Produce标注，这种方式被otto官方文档称为<strong>PRODUCING</strong>。如果使用了@Produce来标注生产者（即实现PRODUCING功能），就需要同时在初始化时使用bus.register(this)来注册这个生产者，在销毁组件时调用unregister（）。  </p>
<p>PRODUCING其实类似于EventBus中的StickyEvent。 用rigister方法注册@Produce标注的生产者（被注册的函数需要返回一个事件实例）时， @Produce标注的生产者函数会为所有之前注册了该事件类型的订阅者<strong>分别进行一次回调</strong>，并且此生产者函数也将为在此之后注册的该事件类型的订阅者<strong>分别进行一次回调</strong>。  </p>
<p>Otto没有EventBus中那种可以在任意地方获取StickyEvent的方法，因为虽然PRODUCING与StickyEvent类似，但<strong>Eventbus是通过一个map来缓存StickyEvent的最后一次更新值，不会触发任何函数回调，而Otto的PRODUCING并没有这种缓存，是实时去回调Produce函数来拿到最新值的</strong>。</p>
<p>PRODUCING的定义如下面代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Produce</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TextEvent <span class="title">postEvent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TextEvent(<span class="string">"hahaah"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个总线上（一个bus对象）上，同一时刻同一类型的用@Produce标注的事件生产者只能有一个。官方文档的原文是：</p>
<blockquote>
<p><strong>You may only have one producer per event type registered at a time on a bus.  </strong></p>
</blockquote>
<p>一般在使用EventBus时，会直接采用EventBus.getDefault()来获取系统默认提供的单例对象，然后再该对象（总线对象）上进行实践的发布和订阅。但是otto没有提供默认的单例，一般需要自己在应用程序范围内，自己去手动创建并维护一个otto的bus对象。</p>
<p>Otto在初始化Bus的时候来决定处理事件的执行线程。默认只有ThreadEnforcer.ANY和ThreadEnforcer.MAIN两种。如果需要其他类型的线程控制，需要自己实现ThreadEnforcer接口。相对而言，EventBus的控制更精细更简单。   </p>
<h2 id="与EventBus的对比">与EventBus的对比</h2><p><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-8-28/24002070.jpg" alt="Otto与EventBus的对比"></p>
<h2 id="详细使用实例"><a href="id:详细使用实例" target="_blank" rel="external">详细使用实例</a></h2><p>1.在build.gradle的dependencies中加入以下内容：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.squareup:otto:1.3.8'</span></span><br></pre></td></tr></table></figure>
<p>2.根据业务需要定义事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextEvent</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.创建一个类，在整个应用程序范围内持有一个总线对象。（使用EventBus不需要这一步，因为EventBus已近替我们实现好了默认的单例对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bus bus = <span class="keyword">new</span> Bus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.在需要订阅事件的组件中（即订阅者，假设是一个Activity），做以下三个工作：  </p>
<ul>
<li>在初始化组件时向总线注册自己为某类型事件的订阅者  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main3);</span><br><span class="line">       tv = (TextView)findViewById(R.id.getdatatv);</span><br><span class="line">       </span><br><span class="line">       MyApplicationUtil.bus.register(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现事件处理函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Subscribe</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEvent</span><span class="params">(TextEvent event)</span></span>&#123;</span><br><span class="line">       tv.setText(event.getData());</span><br><span class="line">       Log.d(<span class="string">"TAG"</span>,  <span class="string">"==in Main3Activity==   getEvent:"</span> + event.getData());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在组件销毁时反注册订阅者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onDestroy();</span><br><span class="line">       MyApplicationUtil.bus.unregister(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>5.在产生事件的组件（生产者）中，如果只是发送普通事件，就直接调用bus对象的post方法即可，之前注册的订阅者就可以接收到这个事件了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyApplicationUtil.bus.post(<span class="keyword">new</span> TextEvent(dataEditText.getText().toString()));</span><br></pre></td></tr></table></figure>
<p>6.如果需要实现PRODUCING功能（即类似StickyEvent功能），就需要用@Producer显示标注生产者，同时也要对该生产者进行注册和反注册，如下面代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main2);</span><br><span class="line">       dataEditText = (EditText)findViewById(R.id.activity2_et);</span><br><span class="line">       btn1 = (Button)findViewById(R.id.activity2_btn1);</span><br><span class="line">       btn1.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       MyApplicationUtil.bus.register(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="annotation">@Produce</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TextEvent <span class="title">postEvent</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> TextEvent(<span class="string">"hahaah"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onDestroy();</span><br><span class="line">       MyApplicationUtil.bus.unregister(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>按照这种方式显示定义了生产者之后，之前在此bus上注册过的所有该类型事件的订阅者都会接收到本事件的实例。之后再再此bus上注册的此类型的新的订阅者同样能够接收到本事件实例。</p>
<hr>
<p>参考资料</p>
<ol>
<li><p><a href="https://github.com/square/otto" target="_blank" rel="external">官方下载：https://github.com/square/otto</a></p>
</li>
<li><p><a href="http://square.github.io/otto/" target="_blank" rel="external">官方使用说明：http://square.github.io/otto/</a></p>
</li>
<li><p><a href="http://blog.csdn.net/wangjia55/article/details/17148535" target="_blank" rel="external">Otto介绍：http://blog.csdn.net/wangjia55/article/details/17148535</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/qianxudetianxia/p/4216949.html" target="_blank" rel="external">使用事件总线框架EventBus和Otto：<br>http://www.cnblogs.com/qianxudetianxia/p/4216949.html</a></p>
</li>
<li><p><a href="http://m.blog.csdn.net/blog/Estellise/41758401" target="_blank" rel="external">Android组件间通信机解耦——Android EventBus和Otto框架：<br>http://m.blog.csdn.net/blog/Estellise/41758401</a></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在学习完EventBus后，发现与之类似的事件库还有otto，于是我也学习了一下。在网上找到的大部分博客其实都是对otto官方文档的中文翻译而已，对生产者的@Produce、PUBLISHING、PRODUCING之间的关系没有深入解释，也没有对EventBus的StickyEvnet与Otto中类似机制的对比，而这正是我想了解的。所以就自己写demo做了些实验，总结了这篇学习笔记。</p>
<p><strong><br>本文的Otto指的是：square/otto<br>EventBus指的是：greenrobot/EventBus<br>Github上有很多同名项目，不要搞错。
</strong></p>
<p>本文档前面是对Otto各方面的介绍。如果要学习快速使用，可以直接跳转到后面的<a href="#详细使用实例">详细使用实例</a>部分。</p>
<h2 id="特点">特点</h2><p>Otto的作用与EventBus类似，都是用于组件间通信，降低不同的类相互之间的耦合。如果不熟悉EventBus，可以先了解EventBus，下文涉及到otto与EventBus的对比。</p>
<p>Otto可以随便定义订阅者的消息处理函数的函数名，采用注解的方式来识别生产函数和消费函数（@Produce和@Subscribe），这是与EventBus明显的不同。<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.carrotsight.com/tags/Android/"/>
    
      <category term="EventBus" scheme="http://www.carrotsight.com/tags/EventBus/"/>
    
      <category term="Otto" scheme="http://www.carrotsight.com/tags/Otto/"/>
    
      <category term="观察者模式" scheme="http://www.carrotsight.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Android" scheme="http://www.carrotsight.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[EventBus学习总结]]></title>
    <link href="http://www.carrotsight.com/2015/09/14/2015-9-14-EventBus%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html"/>
    <id>http://www.carrotsight.com/2015/09/14/2015-9-14-EventBus学习总结.html</id>
    <published>2015-09-14T12:12:43.000Z</published>
    <updated>2015-12-02T13:07:27.000Z</updated>
    <content type="html"><![CDATA[<p>这两天对Github上很火的eventbus进行了学习，查阅了一些博客，也自己写代码做了实验，写下此总结文档。<br>本文档前面是对EventBus各方面的介绍。如果要学习快速使用，可以直接跳转到后面的<a href="#详细使用实例">详细使用实例</a>部分。</p>
<p><strong>本文EventBus指的是：greenrobot/EventBus<br>Github上有很多同名项目，不要搞错。</strong><br>EventBus是使用观察者模式来替代Intent、Handler、Broadcast的在Activity、Fragment、Service之间传递消息的机制。能降低组件间的耦合，使代码更简洁。</p>
<h2 id="概念图">概念图</h2><p><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-8-28/38822932.jpg" alt="EventBus概念图"><br><a id="more"></a></p>
<h2 id="特点">特点</h2><p>“事件”是一个POJO，根据自己需要自己随便定义的一个JAVA类，包含需要传递给其他组件的信息。  </p>
<p>事件发布者不需要注册，直接使用EventBus.getDefault().post(new TextEvent(“我有一头小毛驴”))。其中TextEvent是一个自定义类。  </p>
<p>事件订阅者（接受者、处理者）需要在onCreate()方法中通过EventBus.getDefault().register(this)注册自己，在onDestroy()方法中通过EventBus.getDefault().unregister(this)取消注册。同时，需要至少实现4种onEventXXX方法中的一种。   </p>
<p>支持4种事件响应模式：  </p>
<blockquote>
<ol>
<li>MainThread：对应的响应函数写法为onEventMainThread，事件响应函数会在Android应用的主线程(大部分情况下都是UI线程)中执行。</li>
<li>PostThread：对应的响应函数写法为onEvent，即默认的处理方式就是post方式。事件响应函数和事件发布在同一线程中执行。这个是默认值，这样可以避免线程切换。</li>
<li>BackgroundThread：对应的响应函数写法为onEventBackgroundThread，事件响应函数会在一个后台线程中执行。如果事件发布函数不是在主线程中，则会立即在事件发布线程中执行响应函数。如果事件发布函数在主线程中，EventBus则会在唯一的一个后台线程中按照顺序来执行所有的后台事件响应函数。</li>
<li>Async：对应的响应函数写法为onEventAsync，每接收到一个事件都会开启一个异步线程执行。  </li>
</ol>
</blockquote>
<p>前3种响应函数都要求其中不能有耗时操作，防止UI更新、事件分发或新事件的处理等操作被阻塞。 </p>
<p>通过实验，如果在同一个订阅者中对同一个事件同时注册了这4种响应函数，则控制台打印的时间处理函数顺序为 :</p>
<blockquote>
<p>onEvent()-&gt;onEventMainThread()-&gt;onEventAsync()-&gt;onEventBackgroundThread()</p>
</blockquote>
<p>或</p>
<blockquote>
<p>onEvent()-&gt;onEventMainThread()-&gt;onEventBackgroundThread()-&gt;onEventAsync()。 </p>
</blockquote>
<p>由于onEventBackgroundThread（）和onEventAsync（）都是在后台线程执行的，包括在控制台打印函数名的操作，所以此顺序不一定就是这几个函数被触发的顺序。</p>
<h2 id="优先级">优先级</h2><p>EventBus在注册订阅者时需要指定此订阅者的优先级，用整型数表示，数字越大优先级越高。如果不显示指定优先级，则默认为0。优先级可以为负数。  </p>
<p>对于同一个事件的多个订阅者，高优先级的订阅者会先接收到Event。</p>
<p>接收到Event的订阅者可以决定是否取消事件的传递，来使后面的订阅者无法接收到Event。方法是在onEvent方法中调用EventBus.getDefault().cancelEventDelivery(event)，也就是说，只能在Post线程的onEvent方法中取消事件的传递。 </p>
<p>经过实验，<strong>相同优先级的订阅者是按照注册的先后顺序来接收事件的</strong>。先接收到事件的订阅者如果在onEvent()方法中调用EventBus.getDefault().cancelEventDelivery(event)，同样可以中断事件继续传播，但中断得不彻底，紧随其后的1个订阅者仍然有可能接收到事件。</p>
<p><strong><em>注意：</em></strong>  </p>
<p>如果第一个接收到时间的订阅者在任何一个订阅函数中对接收到的event的内容做了修改，那么后续的其他订阅者的所有onEventXXX函数接受到的event也都是被修改的。即<strong>post操作只产生一个event对象，所有订阅者的onEventXXX函数接受到的都是同一个对象的引用</strong>。</p>
<p>如果event被生产者post之后，订阅者接收到了事件并足够快的对该event的某些字段做了修改，那么生产者在post语句之后对event的引用也会体现出字段的修改。这里的“足够快”没有定论，实验的每次结果都有差异，不过基本的规律是生产者的post（）语句之后的下一条语句，会在所有订阅者的onEvent()和onEventMainThread()都执行完成后才执行。而onEventAsync()和onEventBackgroundThread()相对于post（）下一条语句的执行顺序则没有定论。</p>
<h2 id="关于cancelEventDelivery的问题">关于cancelEventDelivery的问题</h2><p>如果在post线程的onEvent方法中，先有一段特别耗时的操作，然后才调用cancelEventDelivery，那么后面的订阅者有可能因为cancelEventDelivery没被即时执行而接收到事件吗？比如订阅者1的onEvent方法是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(TextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">99999999</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = i;</span><br><span class="line">            &#125;</span><br><span class="line">            EventBus.getDefault().cancelEventDelivery(event);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么本该在订阅者1后面才接收到事件的订阅者2会接收到event吗？也许EventBus会在for循环这段时间内已近把事件传递给订阅者2了，毕竟这时还没有执行EventBus.getDefault().cancelEventDelivery(event)？</p>
<p>带着这个问题，跟进了一下EventBus的源码，有以下发现。  </p>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-2/91530689.jpg" alt=""></p>
<p>在事件生产者调用post方法时，Eventbus内部是通过调用这个postSingleEventForEventType<br>方法来进行消息传递的，一旦EventBus.getDefault().cancelEventDelivery<br>(event)方法被调用，aborted就被置为false，这个for循环就会停止，消息不会再向后面任何订阅者的任何一种线程函数传递。<br>由于cancelEventDelivery方法只能在post线程的onEvent函数中调用，而这里的postToSubscription方法对于post线程的执行是同步的，所以即使某个订阅者在post线程的onEvent中先进行耗时操作再调用cancelEventDelivery，后面的订阅者也接受不到这个事件，因为postSingleEventForEventType方法还在等待2返回（同步方法）。  </p>
<p>postToSubscription的内部实现如下：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-2/70984573.jpg" alt=""></p>
<p>我用代码在各种线程中都试过了，确实不用担心cancelEventDelivery之前的耗时操作导致在耗时操作期间事件仍然被传递的问题。只有一种例外，就是在post线程的onThread方法中再启新线程进行cancelEventDelivery调用，不会这样做没有意义，因为eventbus已经提供了4种线程模型了，不需要这样多此一举， 相信不会有人这样写代码，就像下面这样：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-2/40991601.jpg" alt=""></p>
<h2 id="基本用法流程3步搞定">基本用法流程3步搞定</h2><p>1.定义事件  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123; <span class="comment">/* Additional fields if needed */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>2.注册订阅者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.register(<span class="keyword">this</span>);<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(AnyEventType event)</span> </span>&#123;<span class="comment">/* Do something */</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>3.发送事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.post(event);</span><br></pre></td></tr></table></figure>
<h2 id="StickyEvent">StickyEvent</h2><p>除了普通的Event，还有一类特殊的StickyEvent，它也是POJO，事件本身和普通事件无区别，只是在注册订阅者注册时需要使用EventBus.getDefault().registerSticky(this)。事件处理函数的函数名也与普通事件的处理函数一样，因为注册为了StickyEvent的监听器，所以EventBus在调用这些事件处理函数时会按照StickyEvent的方式来处理。  </p>
<p>StickyEvent与普通Event的普通就在于，EventBus会自动维护被作为StickyEvent被post出来（即在发布事件时使用EventBus.getDefault().postSticky(new MyEvent())方法）的事件的最后一个副本在缓存中。  </p>
<p>任何时候在任何一个订阅了该事件的订阅者中的任何地方（可以在任何函数中，而不仅仅是在onEventXXX方法中），都可以通过EventBus.getDefault().getStickyEvent(MyEvent.class)来取得该类型事件的最后一次缓存。  </p>
<p>同时，即便事件已经在所有订阅者中传递完成了，如果此时再创建一个新的订阅者（如一个注册了该StickyEvent的Activity），则在订阅者启动后，会自动调用一次该订阅者的noEventXXX方法来处理该StickyEvent。  </p>
<p>也可以在需要的时候，利用removeStickyEvent方法来移除对某种StickyEvent的缓存。</p>
<h2 id="网上博文总结EventBus的优点">网上博文总结EventBus的优点</h2><blockquote>
<ol>
<li>支持在不同类型的线程中处理订阅，包括发布所在线程，UI线程、单一后台线程、异步线程</li>
<li>支持事件优先级定义，支持优先级高的订阅者取消事件继续传递，支持粘性事件，是不是跟系统的有序广播、粘性广播很像啊</li>
<li>不是基于annotations</li>
<li>性能更优</li>
<li>体积小</li>
<li>支持单例创建或创建多个对象</li>
<li>支持根据事件类型订阅</li>
</ol>
</blockquote>
<h2 id="详细使用实例"><a href="id:详细使用实例" target="_blank" rel="external">详细使用实例</a></h2><p>1.准备工作：  </p>
<p>在项目build.gradle的dependencies中加入以下内容：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'de.greenrobot:eventbus:2.4.0'</span></span><br></pre></td></tr></table></figure></p>
<p>2.编写事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextEvent</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    	<span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.在需要订阅该事件的Activity的onCreate（）方法中，把自己注册为订阅者。<br>默认使用EventBus提供的默认总线，即EventBus.getDefault()方法获得的总线，其内部实现了单例模式。自己也可以根据需要定制不同的总线。<br>register()方法是向总线订阅普通事件，registerSticky方法是向总线订阅Sticky事件。只能使用二者当中的一种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    	<span class="comment">//EventBus.getDefault().registerSticky(this);</span></span><br><span class="line">        EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.在注册为订阅者的Activity的onDestroy（）方法中，解除注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">	<span class="keyword">super</span>.onDestroy();</span><br><span class="line">	EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.在注册为订阅者的Activity中，编写事件处理方法。<br>下面的代码列举了4种线程类型的事件处理方法，实际使用时可以根据需要只实现其中的几种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventAsync</span><span class="params">(TextEvent event)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">/* messageTextView.setText(event.getMsg());</span><br><span class="line">           Toast.makeText(this, event.getMsg(), Toast.LENGTH_SHORT).show();*/</span></span><br><span class="line">           Log.d(<span class="string">"TAG"</span>, event.getMsg());</span><br><span class="line">           Log.d(<span class="string">"onEvent"</span>, <span class="string">"onEventAsync()"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(TextEvent event)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           messageTextView.setText(event.getMsg());</span><br><span class="line">           Toast.makeText(<span class="keyword">this</span>, event.getMsg(), Toast.LENGTH_SHORT).show();</span><br><span class="line">           Log.d(<span class="string">"TAG"</span>, event.getMsg());</span><br><span class="line">           Log.d(<span class="string">"onEvent"</span>, <span class="string">"onEvent()"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMainThread</span><span class="params">(TextEvent event)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">/* messageTextView.setText(event.getMsg());</span><br><span class="line">           Toast.makeText(this, event.getMsg(), Toast.LENGTH_SHORT).show();*/</span></span><br><span class="line">           Log.d(<span class="string">"TAG"</span>, event.getMsg());</span><br><span class="line">           Log.d(<span class="string">"onEvent"</span>, <span class="string">"onEventMainThread()"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventBackgroundThread</span><span class="params">(TextEvent event)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">/* messageTextView.setText(event.getMsg());</span><br><span class="line">           Toast.makeText(this, event.getMsg(), Toast.LENGTH_SHORT).show();*/</span></span><br><span class="line">           Log.d(<span class="string">"TAG"</span>, event.getMsg());</span><br><span class="line">           Log.d(<span class="string">"onEvent"</span>, <span class="string">"onEventBackgroundThread()"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>6.在需要产生事件的组件（Activity、Fragment、Service等）中，调用发送事件的方法。<br>下面的代码列举了发送普通事件和发送Sticky事件两种情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (v.getId())&#123;</span><br><span class="line">           <span class="keyword">case</span> R.id.activity8_btn1:</span><br><span class="line">               EventBus.getDefault().post(<span class="keyword">new</span> TextEvent(<span class="string">"我有一头小毛驴"</span>));</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">case</span> R.id.activity8_btn2:</span><br><span class="line">               EventBus.getDefault().postSticky(<span class="keyword">new</span> TextEvent(<span class="string">"我有一头小毛驴"</span>));</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这样，当点击按钮触发onClick（）时，就能在第5步的MainActivity中的onEventXXX方法中接收到事件了。<br>如果发送的是Sticky事件，则可以在任何需要获取该事件的地方通过EventBus.getDefault().getStickyEvent(TextEvent.class)方法来获取该类型的StickyEvent的最后一次数据。</p>
<hr>
<p>参考资料</p>
<ol>
<li><p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">官方下载: https://github.com/greenrobot/EventBus
</a></p>
</li>
<li><p><a href="https://github.com/greenrobot/EventBus/blob/master/HOWTO.md" target="_blank" rel="external">官方使用说明: https://github.com/greenrobot/EventBus/blob/master/HOWTO.md</a></p>
</li>
<li><p><a href="http://blog.csdn.net/marktheone/article/details/47725553" target="_blank" rel="external">EventBus, otto, LocalBroadcast的对比：http://blog.csdn.net/marktheone/article/details/47725553</a></p>
</li>
<li><p><a href="http://blog.csdn.net/harvic880925/article/details/40660137" target="_blank" rel="external">EventBus使用详解：<br>http://blog.csdn.net/harvic880925/article/details/40660137</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/wangjq/archive/2012/07/12/2587966.html" target="_blank" rel="external">观察者模式：<br>http://www.cnblogs.com/wangjq/archive/2012/07/12/2587966.html</a></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两天对Github上很火的eventbus进行了学习，查阅了一些博客，也自己写代码做了实验，写下此总结文档。<br>本文档前面是对EventBus各方面的介绍。如果要学习快速使用，可以直接跳转到后面的<a href="#详细使用实例">详细使用实例</a>部分。</p>
<p><strong>本文EventBus指的是：greenrobot/EventBus<br>Github上有很多同名项目，不要搞错。</strong><br>EventBus是使用观察者模式来替代Intent、Handler、Broadcast的在Activity、Fragment、Service之间传递消息的机制。能降低组件间的耦合，使代码更简洁。</p>
<h2 id="概念图">概念图</h2><p><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-8-28/38822932.jpg" alt="EventBus概念图"><br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.carrotsight.com/tags/Android/"/>
    
      <category term="EventBus" scheme="http://www.carrotsight.com/tags/EventBus/"/>
    
      <category term="Android" scheme="http://www.carrotsight.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Think in Java》并发 - 学习笔记]]></title>
    <link href="http://www.carrotsight.com/2015/09/08/2015-9-8-%E3%80%8AThink-in-Java%E3%80%8B%E5%B9%B6%E5%8F%91-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://www.carrotsight.com/2015/09/08/2015-9-8-《Think-in-Java》并发-学习笔记.html</id>
    <published>2015-09-08T08:08:15.000Z</published>
    <updated>2015-12-03T08:07:13.000Z</updated>
    <content type="html"><![CDATA[<p>1.Executor允许你管理异步任务的执行，而无须显示地管理线程的生命周期。Executor在Java SE5/6中是启动任务的优选方法。可以使用Executor来代替显示地创建Thread对象。  </p>
<p>2.ExecutorService知道如何构建恰当的上下文来执行Runnable对象。  </p>
<p>3.CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后再它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。只有当这种方式会引发问题时，才需要切换到FixedThreadPool。<br><a id="more"></a><br>4.SingleThreadExecutor就像是线程数量为1的FixedThreadPool。如果向SingleThreadExecutor提交了多个任务，那么这些任务将排队，每个任务都会在下一个任务开始之前运行结束，所有的任务将使用相同的线程。SingleThreadExecutor会序列化所有提交给它的任务，并会维护它自己（隐藏）的悬挂任务队列。<br>SingleThreadExecutor确保任何时刻在任何线程中都只有唯一的任务在运行，就不需要在共享资源上处理同步。  </p>
<p>5.Runnable是执行工作的独立任务，但是他不返回任何值。如果希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口。在Java SE5中引入的Callable是一种具有类型参数的泛型，它的类型参数表示的是从方法call（）（而不是run（））中返回的值，并且必须使用ExecutorService.submit（）方法调用它。<br>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread.sleep((<span class="keyword">new</span> Random()).nextInt(<span class="number">2000</span>) + <span class="number">1000</span>);<span class="comment">//在这里随机睡眠时间，为了测试Future.isDone()的效果</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"TaskWithResult id: "</span> + id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">		ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			results.add(exec.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(Future&lt;String&gt; fs : results)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"\n==taskIndex "</span> + results.indexOf(fs) + <span class="string">"=="</span>);</span><br><span class="line">				System.out.println(<span class="string">"isDone(): "</span> + fs.isDone());</span><br><span class="line">				System.out.println(fs.get());</span><br><span class="line">				System.out.println(<span class="string">"isDone(): "</span> + fs.isDone());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">				exec.shutdown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<blockquote>
<p>==taskIndex 0==<br>isDone(): false<br>TaskWithResult id: 0<br>isDone(): true</p>
<p>==taskIndex 1==<br>isDone(): false<br>TaskWithResult id: 1<br>isDone(): true</p>
<p>==taskIndex 2==<br>isDone(): true<br>TaskWithResult id: 2<br>isDone(): true</p>
<p>==taskIndex 3==<br>isDone(): false<br>TaskWithResult id: 3<br>isDone(): true</p>
<p>==taskIndex 4==<br>isDone(): true<br>TaskWithResult id: 4<br>isDone(): true</p>
<p>==taskIndex 5==<br>isDone(): true<br>TaskWithResult id: 5<br>isDone(): true</p>
<p>==taskIndex 6==<br>isDone(): true<br>TaskWithResult id: 6<br>isDone(): true</p>
<p>==taskIndex 7==<br>isDone(): false<br>TaskWithResult id: 7<br>isDone(): true</p>
<p>==taskIndex 8==<br>isDone(): true<br>TaskWithResult id: 8<br>isDone(): true</p>
<p>==taskIndex 9==<br>isDone(): true<br>TaskWithResult id: 9<br>isDone(): true</p>
</blockquote>
<p>且每当输出到isDone(): false的地方，输出线程就会卡住，直到取到这个线程的返回值后，才会继续后续的打印。  </p>
<p>Future的javadoc说明如下：  </p>
<blockquote>
<p>A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the cancel method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future&lt;?&gt; and return null as a result of the underlying task.</p>
</blockquote>
<p>Future.get()方法的javadoc说明如下：  </p>
<blockquote>
<p>Waits if necessary for the computation to complete, and then retrieves its result.</p>
</blockquote>
<p>6.调度器倾向于让优先级最高的线程先执行。如果要设置线程的优先级，应该在run（）方法体中使用<br><code>Thread.currentThread().setPriority(newPriority)</code>来设置，而不要在构造器中设置。<br>不同操作系统对优先级的分级不同，为了可移植性，应该只使用MAX_PRIORITY、NORM_PRIORITY和MIN_PRIORITY三种级别。  </p>
<p>7.yield（）方法会暗示线程调度器，我的工作做得差不多了，具有相同优先级的其他线程可以运行了。但这仅仅是一个暗示，没有任何机制保证它将被采纳。所以，不能依赖于yield（）。实际上，yield（）经常被误用。  </p>
<p>8.所谓后台（daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，<strong>当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程</strong>。反过来说，只要有任何非后台线程还在运行，程序就不会终止。<br>必须在线程启动之前调用setDaemon（）方法才能把它设置为后台线程，如以下代码： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread daemon = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SimpleDaemon());</span><br><span class="line">daemon.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">daemon.start();</span><br></pre></td></tr></table></figure>
<p>可以用isDaemon()方法来确定线程是否是一个后台线程。如果是一个后台线程，那么它创建的任何子线程都将被自动设置成后台线程。</p>
<p>9.是线程睡眠时可以调用  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.MILLISECONDS.sleep(timeout);</span><br><span class="line">TimeUnit.HOURS.sleep(timeout);</span><br><span class="line">TimeUnit.MICROSECONDS.sleep(timeout);</span><br></pre></td></tr></table></figure>
<p>等方法来代替直接调用<code>Thread.sleep(timeout)</code>方法，这样时间的长度就更直观，这些方法内部会自动调用Thread.sleep(timeout)方法。  </p>
<p>10.join()方法：  </p>
<ul>
<li>一个线程可以在其他线程之上调用join（）方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程t上调用t.join()，此线程将被挂起，直到目标线程t结束才恢复（即t.isAlive()返回为假）。  </li>
<li>可以在调用join()时带上一个超时参数（单位可以是毫秒，或者毫秒和纳秒），这样如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回。</li>
<li>对join()方法的调用可以被中断，做法是在调用join（）的线程上再次调用interrupt()方法。  </li>
</ul>
<p>11.由于线程的本质特性，不能捕获从线程中逃逸的异常，即使在主线程中执行子线程任务时把它包在try-catch块中，任然无法捕获到逃逸的异常，异常会直接向外传播的控制台。为了捕获异常，可以在每个新创建的Thread对象上附着一个Thread.UncaughtExceptionHandler。</p>
<p>例如下面的代码：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"I throw this Exception on purpose!"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExceptionCaughtTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">			t1.start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.out.println(<span class="string">"Haha! Exception caught!!!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行的结果为：  </p>
<blockquote>
<p>Exception in thread “Thread-0” java.lang.RuntimeException: I throw this Exception on purpose!<br>    at MyThread.run(ThreadExceptionCaughtTest.java:5)</p>
</blockquote>
<p>可见try-catch并不能捕获到我在MyThread中抛出的异常。  </p>
<p>那么我为MyThread附加一个我自己实现的UncaughtExceptionHandler，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"I throw this Exception on purpose!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Haha! I caught : "</span> + e);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExceptionCaughtTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">			t1.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">			t1.start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.out.println(<span class="string">"Haha! Exception caught!!!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
<p>执行的结果为：</p>
<blockquote>
<p>Haha! I caught : java.lang.RuntimeException: I throw this Exception on purpose!</p>
</blockquote>
<p>可以看到MyUncaughtExceptionHandler成功捕获到了MyThread抛出的异常，try-catch仍然没有捕获到异常。  </p>
<p>12.关于<strong>synchronized方法</strong><br>所有对象都自动含有单一的锁（也称为监视器）。当在对象上调用其任意synchronized方法的时候，此对象都被加锁，<strong>这时该对象上的其他synchronized方法只有等到前一个方法调用完毕并释放了锁之后才能被调用</strong>。<br>例如这段代码：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAccount</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> account;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserAccount</span><span class="params">(<span class="keyword">int</span> account)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.account = account;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">			System.out.println(<span class="string">"incAccount result: "</span> + ++account);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"decAccount result: "</span> + --account);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		UserAccount ua = <span class="keyword">new</span> UserAccount(<span class="number">200</span>);</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				ua.incAccount();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				ua.decAccount();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(<span class="string">"===start==="</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
<p>其执行结果始终为：  </p>
<blockquote>
<p>===start===<br>incAccount result: 201<br>decAccount result: 200</p>
</blockquote>
<p>且控制台打印出“===start===”后，会暂停2秒钟才继续输出后面的2行结果。</p>
<p>而如果把函数decAccount（）前面的synchronized修饰符去掉，则打印结果为：   </p>
<blockquote>
<p>===start===<br>decAccount result: 199<br>incAccount result: 200</p>
</blockquote>
<p>且前两行结果是瞬间打印出来的，然后暂停了2秒，才输出最后一行结果。  </p>
<p>13.在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突。<br>如果你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关的方法。</p>
<p>14.一个任务可以多次获得对象的锁。JVM负责跟踪对象被加锁的次数。只有首先获得了锁的任务才能允许继续获取多个锁。  </p>
<p>15.针对每个类，也有一个锁，作为类的Class对象的一部分，所以synchronized static方法可以在类的范围内防止对static数据的并发访问。  </p>
<p>16.在java.util.concurrent.locks中定义了显示的互斥机制Lock。Lock对象必须被显示地创建、锁定和释放。<br>好的使用习惯是，使用try-finally语句块，将lock（）放在try中，将unlock（）放在finally中。注意，return语句必须放在try子句中，以确保unlock（）不会过早发生，从而将数据暴露给第二个任务。  </p>
<p>17.如果将一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改。即便使用了本地缓存，情况也确实如此，volatile域会立即被写入到主存中，而读取操作就发生在主存中。<br>如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则，这个域就应该只能经由同步来访问。同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护，那就不必将其设置为是volatile的。<br>使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域。你的第一选择应该是使用synchronized关键字，这是最安全的方式，而尝试其他任何方式都是有风险的。（我理解这句话想表达的意思是，尽量不要使用volatile关键字，而是使用synchronized关键字或者Lock类。）  </p>
<p>18.调用sleep()和yield（）的时候并没有释放锁。<br>调用wait()的时候锁被释放。<br>wait()、notify（）以及notifyAll()有一个比较特殊的方面，那就是这些方法是基类Object的一部分，而不是属于Thread的一部分，只能在synchronized方法或synchronized块中调用这几个方法。sleep（）可以在非synchronized控制方法里调用，是因为不用操作锁。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1.Executor允许你管理异步任务的执行，而无须显示地管理线程的生命周期。Executor在Java SE5/6中是启动任务的优选方法。可以使用Executor来代替显示地创建Thread对象。  </p>
<p>2.ExecutorService知道如何构建恰当的上下文来执行Runnable对象。  </p>
<p>3.CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后再它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。只有当这种方式会引发问题时，才需要切换到FixedThreadPool。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://www.carrotsight.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.carrotsight.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://www.carrotsight.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java" scheme="http://www.carrotsight.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【FLEX bug:无法启动服务，因为fml文件损坏】的解决办法]]></title>
    <link href="http://www.carrotsight.com/2013/12/02/2013-12-2-FLEX%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%9B%A0%E4%B8%BAfml%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F.html"/>
    <id>http://www.carrotsight.com/2013/12/02/2013-12-2-FLEX无法启动服务因为fml文件损坏.html</id>
    <published>2013-12-02T05:01:15.000Z</published>
    <updated>2015-12-03T08:06:26.000Z</updated>
    <content type="html"><![CDATA[<p>在Flash Builder中，提示</p>
<blockquote>
<p>FLEX bug:无法启动服务，因为fml文件损坏。<br><a id="more"></a><br>具体错误提示忘了，差不多就是这句话。</p>
</blockquote>
<p>如果遇到这种情况，把项目目录下的.model/<em>*</em>.fml文件用文本编辑器打开，删掉坏掉的服务，也就是<service>标签之间的部分，然后在回去看FLEX，就可以删掉之前的数据服务了。</service></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Flash Builder中，提示</p>
<blockquote>
<p>FLEX bug:无法启动服务，因为fml文件损坏。<br>]]>
    
    </summary>
    
      <category term="Flex" scheme="http://www.carrotsight.com/categories/Flex/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Flex中datagrid中checkbox的全选实现]]></title>
    <link href="http://www.carrotsight.com/2013/04/03/2013-4-3-Flex%E4%B8%ADdatagrid%E4%B8%ADcheckbox%E7%9A%84%E5%85%A8%E9%80%89%E5%AE%9E%E7%8E%B0.html"/>
    <id>http://www.carrotsight.com/2013/04/03/2013-4-3-Flex中datagrid中checkbox的全选实现.html</id>
    <published>2013-04-03T03:44:21.000Z</published>
    <updated>2015-12-03T08:05:31.000Z</updated>
    <content type="html"><![CDATA[<p>假设住程序的表格中有一列是checkbox，用户勾选后进行其他操作，定义为：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">chkChooseAll_changeHandler</span><span class="params">(event:Event)</span><span class="type">:void</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> <span class="keyword">each</span>(<span class="keyword">var</span> item:XML <span class="keyword">in</span> adg.dataProvider)</span><br><span class="line">   &#123;</span><br><span class="line">       item.@selected = chkChooseAll.selected;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>即将表格数据源对应项的selectd属性设置为全选框的选中状态。</p>
<p>下面主要要处理表格中chkCol列对属性改变的响应，即自动更新全选状态。方法为：<br>在itemRender中，重载data属性的set方法，如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> <span class="title">data</span><span class="params">(value:Object)</span><span class="type">:void</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value.@selected == <span class="string">"true"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         chkbox.selected = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         chkbox.selected = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的itemRender源码如下图：</p>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/FlexItemRender.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设住程序的表格中有一列是checkbox，用户勾选后进行其他操作，定义为：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">chkChooseAll_changeHandler</span><span class="params">(event:Event)</span><span class="type">:void</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> <span class="keyword">each</span>(<span class="keyword">var</span> item:XML <span class="keyword">in</span> adg.dataProvider)</span><br><span class="line">   &#123;</span><br><span class="line">       item.@selected = chkChooseAll.selected;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Flex" scheme="http://www.carrotsight.com/categories/Flex/"/>
    
  </entry>
  
</feed>
