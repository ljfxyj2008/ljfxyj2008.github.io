<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ljfxyj2008风巢]]></title>
  <subtitle><![CDATA[记录点滴]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.carrotsight.com/"/>
  <updated>2016-02-01T03:45:24.000Z</updated>
  <id>http://www.carrotsight.com/</id>
  
  <author>
    <name><![CDATA[ljfxyj2008]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[浅谈Android自定义Lint规则的实现 （二）]]></title>
    <link href="http://www.carrotsight.com/2016/02/01/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%BA%8C%EF%BC%89.html"/>
    <id>http://www.carrotsight.com/2016/02/01/浅谈Android自定义Lint规则的实现 （二）.html</id>
    <published>2016-02-01T03:30:35.000Z</published>
    <updated>2016-02-01T03:45:24.000Z</updated>
    <content type="html"><![CDATA[<p>上一篇文章针对Android自定义Lint规则的总体开发流程做了介绍，本文针对java源代码Lint检测方法做细节介绍。由于网上关于自定义Lint规则的文章比较有限，且对于lombok.ast库的相关细节几乎没有文档可用，所以本文内容主要是根据自身开发经验做的总结，难免会有疏漏或错误，还请各位大神批评指正。</p>
<a id="more"></a>
<h2 id="检测Java源代码">检测Java源代码</h2><p>针对Java源代码做Lint检测，我们需要让自定义的XXXDetector类继承com.android.tools.lint.detector.api.Detector类，并实现com.android.tools.lint.detector.api.Detector.JavaScanner接口，同时在该XXXDetector对应的Issue中定义检测的范围为com.android.tools.lint.detector.api.Scope.JAVA_FILE_SCOPE，如图：  </p>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-29/14308921.jpg" alt="">  </p>
<p>其实我们查看Detector类的源码会发现，JavaScanner是在Detector中定义的内部接口，JavaScanner接口中定义的10个方法，都以完全相同的签名在Detector中重新定义了一遍。所以，Detector相当于是JavaScanner接口的适配器，上图中我们自定义的ActivityFragmentLayoutNameDetector类可以根据需要只实现JavaScanner接口的部分方法，而不需要实现全部10个方法。<br>作为7个Scanner（这7个Scanner在上一篇中有介绍，这里的JavaScanner就是其中一个）的外部类，Detector实际上是它们共同的适配器。  </p>
<p>JavaScanner接口定义的10个方法如下图所示：</p>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-7/55021440.jpg" alt="">  </p>
<p>从上图可以看到，JavaScanner定义的很多方法都用到了Node类，还出现了ConstructorInvocation、MethodInvocation等类。那么这些类到底代表什么，我们如何在java源代码的分析中使用这些类呢？要搞清楚这个问题，我们首先要介绍一下Abstract Syntax Tree。</p>
<h3 id="Abstract_Syntax_Tree是什么">Abstract Syntax Tree是什么</h3><p>在计算机科学中，Abstract Syntax Tree（简称AST）是对程序设计语言写成的源代码的一种树型表示。树中的每一个节点（node）代表在源代码中存在的一个构建体。之说以说语法树是“抽象的”（Abstract）是因为它并没有把真实语法的所有细节都表达出来，比如成对匹配的括号就隐式的用树结构来表达，一条if-condition-then语句可能就用一个具有3个分支的节点来表达。  </p>
<p>在Java和Android开发工作中，IDE工具带给我们的很多便利功能都是通过AST来实现的，比如Quick Fix、Quick Assist、修改一个变量名时自动把所有对该变量的引用都同步修改、以及在Android Studio中摁住<code>⌘</code>键的同时点击一个类名会跳转到那个类的定义文件等。  </p>
<p>AST与XML文件的DOM模型类似，允许你通过修改树模型来把这些修改反映到Java源代码中。不过我们在自定义Lint使用AST的过程中一般不涉及修改节点。一个AST的例子如下图:  </p>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-29/67433168.jpg" alt=""></p>
<p>在查看Android Lint源码的过程中可以发现，它涉及到两套AST的实现API，一套是<code>Ecj（Eclipse Java development tools）</code>的，在包<code>org.eclipse.jdt.internal.compiler.ast</code>中；另一套是<code>lombok.ast</code>的。系统暴露给我们允许我们直接用来扩展Lint规则的是lombok.ast的AST API。JavaScanner定义的10个方法中的Node指的就是lombok.ast.Node，而ConstructorInvocation、MethodInvocation都是lombok.ast.Node的子类。</p>
<p>如果你对AST感兴趣，可以查看<a href="http://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/" target="_blank" rel="external">Eclipse网站的AST介绍文档</a>。</p>
<h3 id="JavaScanner接口方法的使用">JavaScanner接口方法的使用</h3><p>前面的图片显示了JavaScanner接口定义的10个方法，这些方法有些可以单独使用，有些需要配合使用，这里介绍常见的用法。  </p>
<p>【1】getApplicableNodeTypes（）需要与createJavaVisitor（）配合使用。  </p>
<p>getApplicableNodeTypes（）返回我们感兴趣的Node列表，然后在createJavaVisitor（）返回的AstVisitor中去处理这些Node。<br>比如，我们想对java源代码中的if、try、for语句进行检测，就可以这样实现getApplicableNodeTypes（）：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> Node&gt;&gt; getApplicableNodeTypes() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.<span class="keyword">asList</span>(<span class="keyword">Try</span>.<span class="keyword">class</span>, <span class="keyword">If</span>.<span class="keyword">class</span>, <span class="keyword">For</span>.<span class="keyword">class</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的Try、If、For都是lombok.ast.Node的子类。</p>
<p>然后定义一个AstVisitor的子类，并在createJavaVisitor（）中返回它的一个实例，那么在java源码中出现的try、if、for语句对应的node就会触发ForIfTryBlockVisitor中对应的回调函数：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">AstVisitor <span class="title">createJavaVisitor</span><span class="params">(@NonNull JavaContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForIfTryBlockVisitor(context);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ForIfTryBlockVisitor</span> <span class="keyword">extends</span> <span class="title">ForwardingAstVisitor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> JavaContext mContext;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ForIfTryBlockVisitor</span><span class="params">(JavaContext context)</span> </span>&#123;</span><br><span class="line">            mContext = context;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">visitTry</span><span class="params">(Try node)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//... 在这里对try语句做你需要的检查</span></span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">visitTry</span><span class="params">(node)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">visitFor</span><span class="params">(For node)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//... 在这里对for语句做你需要的检查</span></span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">visitFor</span><span class="params">(node)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">visitIf</span><span class="params">(If node)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//... 在这里对if语句做你需要的检查  </span></span><br><span class="line">                      </span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">visitIf</span><span class="params">(node)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【2】getApplicableMethodNames()需要与void visitMethod(JavaContext context, AstVisitor visitor,  MethodInvocation node)配合使用，此时createJavaVisitor（）根据实际需求可有可无。  </p>
<p>这里getApplicableMethodNames()用来返回你感兴趣的那些方法调用列表，这些方法调用对应的node每一次出现都会触发visitMethod(JavaContext context, AstVisitor visitor,  MethodInvocation node)方法被回调。  </p>
<p>例如，我想针对java源代码中所有调用setContentView（）和inflate（）的代码进行检查，可以这样定义getApplicableMethodNames（）：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; getApplicableMethodNames() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> Arrays.<span class="title">asList</span><span class="params">(<span class="string">"setContentView"</span>, <span class="string">"inflate"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在visitMethod方法中做具体处理：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> visitMethod(<span class="keyword">@NonNull</span> JavaContext context, AstVisitor visitor, <span class="keyword">@NonNull</span> MethodInvocation node) &#123;</span><br><span class="line">    String methodName = node.astName().astValue();</span><br><span class="line">    <span class="keyword">if</span> (methodName.equals(<span class="string">"setContentView"</span>)) &#123;            </span><br><span class="line">        <span class="comment">//在这里做针对setContentView（）调用的具体检查</span></span><br><span class="line">           </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">"inflate"</span>)) &#123;</span><br><span class="line">        <span class="comment">//在这里做针对inflate（）调用的具体检查</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【3】getApplicableConstructorTypes（）需要与visitConstructor(JavaContext context, AstVisitor visitor,ConstructorInvocation node,ResolvedMethod constructor)配合使用，此时createJavaVisitor（）根据实际需求可有可无。  </p>
<p>这里getApplicableConstructorTypes（）用来返回你感兴趣的构造方法的列表，系统会在符合条件的构造方法的每一次出现都回调一次visitConstructor方法，而传入的node参数就是对应的调用构造函数在AST中的节点。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> List&lt;<span class="built_in">String</span>&gt; getApplicableConstructorTypes() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(<span class="string">"com.ljfxyj2008.BlankFragment"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> visitConstructor(@NonNull JavaContext context, AstVisitor visitor, @NonNull ConstructorInvocation node, @NonNull JavaParser.ResolvedMethod <span class="constructor"><span class="keyword">constructor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//在这里做针对构造函数调用语句的具体检查</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"===visitConstructor node = "</span> + node</span><br><span class="line">            + <span class="string">"\nlocation = "</span> + context.getLocation(node).getStart().getLine());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【4】appliesToResourceRefs（）需要与visitResourceReference(JavaContext context,AstVisitor visitor,Node node,String type,String name,boolean isFramework)配合使用，用来对感兴趣的资源文件引用的代码进行检查，比如引用了<code>R.layout.main</code>或者<code>R.string.app_name</code>的代码。</p>
<p>这两个方法的实现步骤与前面的几对类似，就不再贴代码了。</p>
<p>在上面介绍的JavaScanner的所有相关API中，最重要的就是createJavaVisitor（）以及该方法返回的AstVisitor。事实上，我们完全可以只利用createJavaVisitor（）方法以及对应的AstVisitor，就完成对java源代码的所有检查工作。之所以Lint系统为JavaScanner接口定义了10个方法，仅仅是为了使得对常见的一些处理需求实现起来更加简洁和高效。</p>
<h3 id="lombok-ast_API中重要的类">lombok.ast API中重要的类</h3><p>既然Lint分析是处理AST中的节点，那么最重要最常用的类当然就是lombok.ast.Node了。<br>lombok.ast.Node实际上是一个接口，定义了对于AST节点的一系列通用操作，有多个抽象子类/接口都实现/继承了它。而在这些抽象子类/接口中我们最常用到的是AbstractNode。AbstractNode是实现了lombok.ast.Node接口的抽象类，它有为数众多的子类，这些子类直接与各种语句直接对应，如图：  </p>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-29/92067715.jpg" alt=""></p>
<p>可以看到常用的case、break、continue、for、if等语句都直接被映射为这里具体的Node子类，而类构造器的声明与调用（即用new关键字来生成一个新对象）也能在这里找到对应的类（即ConstructorDeclaration和ConstructorInvocation）。有了AbstractNode如此丰富的子类，我么对java源码的分析就方便了很多，对于自己想要分析的元素，先找到与它对应的AbstractNode子类，然后在定义自己的AstVisitor时去分析这个对应类即可。  </p>
<p>下面给出一个简单的例子，目的是检查用户有没有使用<code>new Message（）</code>来获取新的android.os.Message对象，如果有这种调用，我们就抛出一个issue，提示用户应该使用效率更高的<code>handler.obtainMessage</code>或者<code>Message.Obtain()</code>来获取，代码如下：  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MessageObtainDetector</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Detector</span></span><br><span class="line"></span>        implements <span class="type">Detector</span>.<span class="type">JavaScanner</span> &#123;</span><br><span class="line">    public static <span class="keyword">final</span> <span class="type">Issue</span> <span class="type">ISSUE</span> = <span class="type">Issue</span>.create(<span class="string">"MessageObtainNotUsed"</span>,</span><br><span class="line">            <span class="string">"You should not call `new Message()` directly."</span>,</span><br><span class="line">            <span class="string">"You should not call `new Message()` directly. Instead, you should use `handler.obtainMessage` or `Message.Obtain()`."</span>,</span><br><span class="line">            <span class="type">Category</span>.<span class="type">CORRECTNESS</span>,</span><br><span class="line">            <span class="number">9</span>,</span><br><span class="line">            <span class="type">Severity</span>.<span class="type">ERROR</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="type">Implementation</span>(<span class="type">MessageObtainDetector</span>.<span class="keyword">class</span>,</span><br><span class="line">                    <span class="type">Scope</span>.<span class="type">JAVA_FILE_SCOPE</span>));</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public <span class="type">List</span>&lt;<span class="type">Class</span>&lt;? <span class="keyword">extends</span> <span class="type">Node</span>&gt;&gt; getApplicableNodeTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Collections</span>.&lt;<span class="type">Class</span>&lt;? <span class="keyword">extends</span> <span class="type">Node</span>&gt;&gt;singletonList(<span class="type">ConstructorInvocation</span>.<span class="keyword">class</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public <span class="type">AstVisitor</span> createJavaVisitor(<span class="annotation">@NonNull</span> <span class="type">JavaContext</span> context) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">MessageObtainVisitor</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageObtainVisitor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ForwardingAstVisitor</span> &#123;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">JavaContext</span> mContext;</span><br><span class="line"></span><br><span class="line">        public <span class="type">MessageObtainVisitor</span>(<span class="type">JavaContext</span> context) &#123;</span><br><span class="line">            mContext = context;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        public boolean visitConstructorInvocation(<span class="type">ConstructorInvocation</span> node) &#123;</span><br><span class="line">            <span class="type">JavaParser</span>.<span class="type">ResolvedNode</span> resolvedType = mContext.resolve(node.astTypeReference());</span><br><span class="line">            <span class="type">JavaParser</span>.<span class="type">ResolvedClass</span> resolvedClass = (<span class="type">JavaParser</span>.<span class="type">ResolvedClass</span>) resolvedType;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; resolvedClass.isSubclassOf(<span class="string">"android.os.Message"</span>, <span class="literal">false</span>))&#123;</span><br><span class="line">                mContext.report(<span class="type">ISSUE</span>,</span><br><span class="line">                        node,</span><br><span class="line">                        mContext.getLocation(node),</span><br><span class="line">                        <span class="string">"You should not call `new Message()` directly."</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitConstructorInvocation(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码结构非常简单，在getApplicableNodeTypes()方法中返回一个List表明我们只对ConstructorInvocation.class感兴趣，然后在createJavaVisitor（）中返回一个自定义的AstVisitor对象，也就是这里的MessageObtainVisitor。因为是检测对构造方法的调用，所以我们在MessageObtainVisitor的定义中只需要重写visitConstructorInvocation（）方法。事实上，即使我们把这里对getApplicableNodeTypes()重写的代码段删除，仍然可以达到检测<code>new Message()</code>的目的，因为只要在MessageObtainVisitor（）中重写了visitXXX（）就可以保证它被调用，但是我们重写getApplicableNodeTypes()可以确保效率更高。  </p>
<p>认真看自定义类MessageObtainVisitor的visitConstructorInvocation（）方法体，可以看到这两行代码:</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JavaParser.ResolvedNode resolvedType = mContext.resolve(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">astTypeReference</span>());</span><br><span class="line">JavaParser.ResolvedClass resolvedClass = (JavaParser.ResolvedClass) resolvedType;</span><br></pre></td></tr></table></figure>
<p>这两行代码非常关键，它把lombok.ast中的类转换成了JavaParser中的类，如此一来我们就可以获取与此node对应的类、变量、方法或注解的详细信息。比如这里的node被转换为resolvedClass后，就可以获取与此类有关的类继承关系。  </p>
<p>由于lombok.ast中各种回调函数（如getApplicableNodeTypes、visitConstructorInvocation等）的参数都是lombok.ast.Node类型，它们包含的都是与AST（抽象语法树）相关的结构性信息，而这些信息对于我们分析java源码的具体业务来说肯定是远远不够的，所以在合适的时机把node转换成JavaParser中各种合适的类型就非常重要。那么在lombok.ast的各种回调函数中传入的node能够被转换成哪些类型呢？看下图：</p>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-2-1/36527297.jpg" alt=""></p>
<p>可以看到类型还是相当丰富的，足够我们对AST各种节点进行详细分析了。</p>
<p>相信细心的朋友应该发现了，上面MessageObtainDetector这个类的代码中是对ConstructorInvocation.class类型的节点进行了分析，而我们在<code>JavaScanner接口方法的使用</code>这一节的第3条介绍了getApplicableConstructorTypes（）和visitConstructor（）方法，它们看起来很类似啊？没错，对于MessageObtainDetector类中进行的构造方法调用检查，我们同样可以用getApplicableConstructorTypes（）和visitConstructor（）来实现，这样就不需要自己去定义一个MessageObtainVisitor了。我们在前面也提到过，JavaScanner中的定义的10个回调方法，其实大部分都是为了简化代码结构与提高执行效率，其实完全可以只用自定义的ForwardingAstVisitor来完成所有检测功能。  </p>
<p>还有一组比较有用的类型转换方法上面没有提到：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassDeclaration surroundingClass = JavaContext.findSurroundingClass(<span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">Node</span> surroundingMethod = JavaContext.findSurroundingMethod(<span class="keyword">node</span><span class="identifier"></span><span class="title">);</span></span><br></pre></td></tr></table></figure>
<p>用这组方法可以获取到此node外围包裹它的类或方法，这是JavaContext类提供的两个静态方法，可以将这两个方法与上面介绍的JavaParser中的ResolvedXXX类型配合使用。</p>
<h2 id="小结">小结</h2><p>使用Lint来分析java源代码，需要实现JavaScanner中合适的回调函数。这些回调函数大部分是为了使得对常见的一些处理需求实现起来更加简洁和高效，事实上我们完全可以只用自定义的<code>AstVisitor</code>来完成所有Lint检查工作，并在createJavaVisitor（）中返回这个自定义AstVisitor的实例。<br>JavaScanner回调函数的node包含的都是与AST结构相关的信息，如果要对node对应的java类、方法等进行详细的业务分析，就需要把node转换成JavaParser中定义的合适类型。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇文章针对Android自定义Lint规则的总体开发流程做了介绍，本文针对java源代码Lint检测方法做细节介绍。由于网上关于自定义Lint规则的文章比较有限，且对于lombok.ast库的相关细节几乎没有文档可用，所以本文内容主要是根据自身开发经验做的总结，难免会有疏漏或错误，还请各位大神批评指正。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.carrotsight.com/tags/Android/"/>
    
      <category term="Lint" scheme="http://www.carrotsight.com/tags/Lint/"/>
    
      <category term="custom lint rules" scheme="http://www.carrotsight.com/tags/custom-lint-rules/"/>
    
      <category term="Android" scheme="http://www.carrotsight.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈Android自定义Lint规则的实现 （一）]]></title>
    <link href="http://www.carrotsight.com/2016/01/29/%E6%B5%85%E8%B0%88Android%E8%87%AA%E5%AE%9A%E4%B9%89Lint%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9E%E7%8E%B0%20%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>http://www.carrotsight.com/2016/01/29/浅谈Android自定义Lint规则的实现 （一）.html</id>
    <published>2016-01-29T03:00:50.000Z</published>
    <updated>2016-02-01T03:47:41.000Z</updated>
    <content type="html"><![CDATA[<p>最近在做一个基于Android Lint的自定义静态代码检查功能库，这里做一个简单的总结。前半部分介绍SDK自带Android Lint的功能与配置使用方法，后半部分介绍扩展自定义Lint规则库的开发流程。</p>
<h2 id="什么是Android_Lint">什么是Android Lint</h2><p>Android Lint是一个静态代码分析工具，它能够对你的Android项目中潜在的bug、可优化的代码、安全性、性能、可用性、可访问性、国际化等进行检查。  </p>
<p>在Android SDK Tools 16及更高的版本中，Lint工具会自动安装。通过它对Android工程源代码进行扫描和检查，可发现潜在的问题，以便程序员及早修正这个问题。Android Lint提供了命令行方式执行，还与IDE（如Android Studio）进行了集成，并提供了xml和html形式的输出报告。  </p>
<p>看了上面的介绍可能大家依然很迷惑“这货到底有啥用”，其实我们平时在Android开发过程中一直在享受Lint带来的便利。比如，下面图中的警告和错误提示，相信大家应该很熟悉吧：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-29/23031672.jpg" alt=""></p>
<a id="more"></a>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-29/32957935.jpg" alt=""></p>
<p>上面的例子分别是java文件与Manifest文件在接受Lint检查后给出的简要lint报告，是Lint与IDE集成后的一种表现形式。事实上，Android Lint目前能检查的项目已经多达220项，检查的范围涵盖了二进制资源文件、java源代码、class文件、gradle配置文件、xml文件、resource文件夹、其他文件等。除了图中这种与IDE结合的简洁报告形式以外，也提供更详细的html和xml形式的报告，让你对自己代码质量的提升空间有更全面的认识。  </p>
<p>在Android Studio中，每一次编译程序时都会自动运行lint分析工具，也可以在需要lint分析的文件夹、包或文件上点击右键选择【Analyze】-&gt;【Inspect Code】。 生成的报告包含了检查过程中发现的问题，并把这些内容按照类别、优先级、严重程度进行了区分。  </p>
<p>Lint工具的处理流程如下图所示：<br><img src="http://developer.android.com/images/tools/lint.png" alt="Lint工作流">  </p>
<p>图中各部分含义如下：  </p>
<ul>
<li>Application source files： 构成你Android project的源文件，包含Java和XML文件，图标，以及ProGuard配置文件。</li>
<li>lint.xml： 配置文件，用来指定你想禁用哪些lint检查功能，以及自定义问题严重度(problem severity levels）。</li>
<li>lint Tool： 一个可以从命令行或Android Studio中运行的静态打码扫描工具。</li>
<li>lint Output： lint检查的结果，可以在命令行中通过lint查看，也可以在Android Studio的Event Log中查看。</li>
</ul>
<h2 id="Android_Lint检查哪些内容">Android Lint检查哪些内容</h2><p>Android Lint内置了很多lint规则，到现在为止是220项检查，总共可以分为以下几类：  </p>
<ul>
<li>Correctness 正确性</li>
<li>Security 安全性</li>
<li>Performance 性能</li>
<li>Usability 可用性</li>
<li>Accessibility 可访问性</li>
<li>Internationalization 国际化</li>
</ul>
<p>下面列举一些常见的lint会检测的代码问题：</p>
<ul>
<li>缺少翻译（和未使用的翻译）</li>
<li>布局性能问题（老的layoutopt工具会用于查找所有这样的问题，和除此之外更多的问题）</li>
<li>未使用的资源</li>
<li>不一致的数组大小（当在多个配置中定义数组）</li>
<li>可访问性和国际化问题（硬编码字符串，缺少contentDescription等）</li>
<li>图标问题 （如丢失密度、 重复图标、 错误尺寸等）</li>
<li>可用性问题 （如不在文本字段上指定输入的类型）</li>
<li>清单错误</li>
</ul>
<blockquote>
<p>如果要查看lint工具支持的issue的完整列表和它们所对应的issue ID，可以使用<code>lint --list</code>命令。</p>
</blockquote>
<h2 id="配置Android_Lint">配置Android Lint</h2><p>默认情况下，当你运行Lint扫描时，它会对Lint支持的所有issue进行检查。你也可以限制只让lint检查特定的issue，并为某些issue分配严重度（severity level）。<br>比如，你可以禁止lint检查那些与你的项目无关的issue，并为lint配置一个更低的severity level来让它报告那些不是非常严重的issue。  </p>
<p>你可以为lint检查配置不同的level：</p>
<ul>
<li>全局（对整个project）</li>
<li>每个project module</li>
<li>每个production module</li>
<li>每个test module</li>
<li>每个open files</li>
<li>每个class hierarchy</li>
<li>每个Version Control System (VCS) scopes</li>
</ul>
<h3 id="在Android_Studio中配置Lint">在Android Studio中配置Lint</h3><p>Android Studio允许你对lint每项检查单独启用或禁用，还可以对项目全局、特定文件夹、特定文件进行专门的lint配置。方法是在Android Studio中点击<code>File &gt; Settings &gt; Project Settings</code>菜单打开<code>Editor-&gt;Inspections</code>页面，里面有它支持的Profiles和Inspections列表，如图：<br><img src="http://developer.android.com/images/tools/studio-inspections-config.png" alt="Inspection Configuration"></p>
<h3 id="配置Lint文件">配置Lint文件</h3><p>你可以在lint.xml文件中指定你对lint检查的偏好设置。如果你要手动创建这个文件，就把它放在你的Android工程的根目录中。如果你是在Android Studio中配置lint偏好，那么lint.xml文件会自动创建并添加到你的Android工程中。  </p>
<p>lint.xml文件的组成结构是，最外面是一对闭合的<lint>标签，里面包含一个或多个<issue>子元素。每一个<issue>被唯一的id属性来标识，整体结构如下：</issue></issue></lint></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">lint</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- list of issues to configure --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">lint</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过设置<issue>标签中的severity属性值，你可以对某个issue禁用lint检查，或者修改某个issue的严重程度（severity level）。</issue></p>
<p>一个实例lint.xml文件如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">lint</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Disable the given check in this project --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">issue</span> <span class="attribute">id</span>=<span class="value">"IconMissingDensityFolder"</span> <span class="attribute">severity</span>=<span class="value">"ignore"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Ignore the ObsoleteLayoutParam issue in the specified files --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">issue</span> <span class="attribute">id</span>=<span class="value">"ObsoleteLayoutParam"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">ignore</span> <span class="attribute">path</span>=<span class="value">"res/layout/activation.xml"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">ignore</span> <span class="attribute">path</span>=<span class="value">"res/layout-xlarge/activation.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">issue</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Ignore the UselessLeaf issue in the specified file --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">issue</span> <span class="attribute">id</span>=<span class="value">"UselessLeaf"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">ignore</span> <span class="attribute">path</span>=<span class="value">"res/layout/main.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">issue</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Change the severity of hardcoded strings to "error" --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">issue</span> <span class="attribute">id</span>=<span class="value">"HardcodedText"</span> <span class="attribute">severity</span>=<span class="value">"error"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">lint</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="在Java源文件或XML源文件中配置lint检查">在Java源文件或XML源文件中配置lint检查</h3><h4 id="在Java中配置lint检查">在Java中配置lint检查</h4><p>要对Android项目中某个Java类或方法禁用lint检查，只需要对那段代码添加<code>@SuppressLint</code>注解即可。<br>下面的例子显示了如何对onCreate方法关闭NewApi这个issue的lint检查。lint工具仍然会对这个类的其他方法进行NewApi issue的检查。例子如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SuppressLint</span>(<span class="string">"NewApi"</span>)</span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.main);</span><br></pre></td></tr></table></figure>
<p>下面的例子显示如何对FeedProvider类关闭ParserError issue的lint检查：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SuppressLint</span>(<span class="string">"ParserError"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FeedProvider</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ContentProvider</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要在Java文件中禁用所有issue的lint检查，使用<code>all</code>关键字，比如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function"><span class="title">SuppressLint</span><span class="params">(<span class="string">"all"</span>)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="在XML中配置lint检查">在XML中配置lint检查</h4><p>如果要对XML文件中某一部分禁用lint检查，可以使用<code>tools:ignore</code>属性来标识。为了让这个属性能够被lint工具识别，必须把下面的命名空间加入你的XML中：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">xmlns</span>:<span class="title">tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span><br></pre></td></tr></table></figure>
<p>下面的例子显示了如何对XML布局文件中的<linearlayout>元素禁用<code>UnusedResources</code> issue的lint检查。<code>ignore</code>属性会被该元素下的子元素继承，在这个例子中，子元素<textview>同样被禁用了lint检查。</textview></linearlayout></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">LinearLayout</span> </span><br><span class="line">    <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">tools:ignore</span>=<span class="value">"UnusedResources"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"@string/auto_update_prompt"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要禁用多个issue时，用逗号把它们分隔开，比如：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">tools:</span>ignore=<span class="string">"NewApi,StringFormatInvalid"</span></span><br></pre></td></tr></table></figure>
<p>要在某个XML元素中对所有issue都禁用lint检查，可以使用<code>all</code>关键字，比如：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">tools:</span>ignore=<span class="string">"all"</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义lint">自定义lint</h2><h3 id="为什么需要自定义lint">为什么需要自定义lint</h3><p>由于每个项目自身的需求，Android Lint默认的检查项目可能不能满足我们的需求。<br>比如我们自己写了一个下拉刷新的库项目，可以让用户直接在xml布局文件中去使用它，但是我们希望用户必须在这个xml元素中定义一个<code>pullmode</code>属性，否则组件无法正常运行，我们希望lint能够对此进行检查，并在用户忘记添加此属性时给出明确的错误提示。再比如，我们的项目中使用了自己封装的日志库，能够方便的在release版本中关闭日志输出来防止app的效率下降，该日志库还能够把日志输出到指定的文件中方便事后分析，这时有一位新成员加入了我们的开发，他可能还是习惯性的用android.util.Log来打印日志，我们希望能够检测到本项目中所有使用了android.util.Log的代码，并发出警告。<br>要满足这些自定义需求，我们就需要通过Android Lint的扩展机制自己定制lint规则。  </p>
<h3 id="自定义lint如何使用">自定义lint如何使用</h3><p>自定义lint是一个纯java项目，以jar的形式输出。有了包含lint规则的jar后，有两种使用方案：</p>
<ul>
<li>方案一：把此jar拷贝到 ~/.android/lint/ 目录中（文件名任意）。此时，这些lint规则针对所有项目生效。</li>
<li>方案二：继续创建一个Android library项目，用来输出包含lint.jar的aar；然后，让目标项目依赖此aar即可使自定义lint规则生效。</li>
</ul>
<p>由于方案一是全局生效的策略，无法单独针对目标项目，用处不大。在工程实践中，我们主要使用方案二。</p>
<p>AAR是Android Library的一种新的二进制分发格式，它把资源也一起打包，这样一来图片和布局资源文件也能够被同时分发。AAR格式文件能够包含一个可选的lint.jar文件，如果一个app依赖了一个包含lint.jar的aar文件，那么这个lint.jar中的规则就会在app的lint任务中被用来做lint检查。</p>
<h3 id="自定义lint实现原理">自定义lint实现原理</h3><p>自定义lint规则是以jar形式存在的，主要通过继承两种类来实现扩展lint功能：<br>①继承<code>IssueRegistry</code>：这是自定义Lint规则的主类或者叫注册类，有且仅有一个，用来注册这个自定义Lint项目中有哪些自定义的issue（issue就是需要lint检查出来并报告给用户的各种问题）需要被检测。<br>②继承<code>Detector</code>并选择Detector中合适的<code>XXXScanner</code>接口来实现：在这里根据自身业务需求，实现各种自定义探测器（Detector),并定义各种issue，根据自身需求的不同这样的类可以有一个或多个。</p>
<p>事实上，Android系统默认的lint检查功能是通过BuiltinIssueRegistry类来定义的，在这个类的源码中可以看到定义的各种issue、detector，如图：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-29/69265121.jpg" alt=""></p>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-29/59960096.jpg" alt="">  </p>
<p>com.android.tools.lint.detector.api.Detector提供了7种XXXScanner接口，根据自身需要选择合适的接口去实现，下面把这7个接口的信息列出：</p>
<p>1、JavaScanner<br>功能：Specialized interface for detectors that scan Java source file parse trees<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-7/55021440.jpg" alt=""></p>
<p>2、ClassScanner<br>功能：Specialized interface for detectors that scan Java class files<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-7/63801235.jpg" alt=""></p>
<p>3、BinaryResourceScanner<br>功能：Specialized interface for detectors that scan binary resource files<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-7/31784308.jpg" alt=""></p>
<p>4、ResourceFolderScanner<br>功能：Specialized interface for detectors that scan resource folders (the folder directory itself, not the individual files within it）<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-7/81593485.jpg" alt=""></p>
<p>5、XmlScanner<br>功能：Specialized interface for detectors that scan XML files<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-7/1707982.jpg" alt=""></p>
<p>6、GradleScanner<br>功能：Specialized interface for detectors that scan Gradle files<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-7/5157796.jpg" alt=""></p>
<p>7、OtherFileScanner<br>功能：Specialized interface for detectors that scan other files<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-7/94526179.jpg" alt=""></p>
<p><strong>实现自定义Lint规则的过程，实际上就是实现detector的过程，每个detector能够定义1个或多个不同类型的issue。</strong>也就是说，一个detector能够检测多种issue，这些issue在逻辑上是有关联的，但这些issue可以拥有不同的严重程度、描述等，并能够独立地被抑制(suppress，即禁用对该issue的检查）。</p>
<h2 id="自定义lint实战">自定义lint实战</h2><p>下面简单演示一下开发一个自定义Lint规则的完整流程。  </p>
<p>【1】在Android Studio中，打开或新建一个工程，然后点击【File -&gt; New -&gt; New Module】，在弹出窗口中选择新建一个Java Library，如图：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-7/98524820.jpg" alt=""></p>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-7/27544737.jpg" alt=""></p>
<p>我们这里把Java Library命名为ljflintrules。</p>
<p>【2】自定义lint规则需要继承一些特定的类，所以需要在ljflintrules的build.gradle中添加依赖:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.android.tools.lint:lint-api:24.3.1'</span></span><br><span class="line"><span class="keyword">compile</span> <span class="string">'com.android.tools.lint:lint-checks:24.3.1'</span></span><br></pre></td></tr></table></figure>
<p>【3】在ljflintrules中新建一个LoggerUsageDetector类，用来检测用户代码中是否使用了<code>android.util.Log</code>类，如果有，就报告一个issue，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LoggerUsageDetector</span> <span class="keyword">extends</span> <span class="title">Detector</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title">Detector</span>.<span class="title">ClassScanner</span> </span>&#123;</span><br><span class="line">    public <span class="literal">static</span> <span class="keyword">final</span> Issue ISSUE = Issue.create(<span class="string">"LogUtilsNotUsed"</span>,</span><br><span class="line">            <span class="string">"You must use our `LogUtils`"</span>,</span><br><span class="line">            <span class="string">"Logging should be avoided in production for security and performance reasons. Therefore, we created a LogUtils that wraps all our calls to Logger and disable them for release flavor."</span>,</span><br><span class="line">            Category.MESSAGES,</span><br><span class="line">            <span class="number">9</span>,</span><br><span class="line">            Severity.ERROR,</span><br><span class="line">            <span class="keyword">new</span> Implementation(LoggerUsageDetector.<span class="keyword">class</span>,</span><br><span class="line">                    Scope.CLASS_FILE_SCOPE));</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; getApplicableCallNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="string">"v"</span>, <span class="string">"d"</span>, <span class="string">"i"</span>, <span class="string">"w"</span>, <span class="string">"e"</span>, <span class="string">"wtf"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; getApplicableMethodNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="string">"v"</span>, <span class="string">"d"</span>, <span class="string">"i"</span>, <span class="string">"w"</span>, <span class="string">"e"</span>, <span class="string">"wtf"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public <span class="keyword">void</span> checkCall(<span class="annotation">@NonNull</span> ClassContext context,</span><br><span class="line">                          <span class="annotation">@NonNull</span> ClassNode classNode,</span><br><span class="line">                          <span class="annotation">@NonNull</span> MethodNode method,</span><br><span class="line">                          <span class="annotation">@NonNull</span> MethodInsnNode call) &#123;</span><br><span class="line">        <span class="built_in">String</span> owner = call.owner;</span><br><span class="line">        <span class="keyword">if</span> (owner.startsWith(<span class="string">"android/util/Log"</span>)) &#123;</span><br><span class="line">            context.report(ISSUE,</span><br><span class="line">                    method,</span><br><span class="line">                    call,</span><br><span class="line">                    context.getLocation(call),</span><br><span class="line">                    <span class="string">"You must use our `LogUtils`"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，我们定义了一个ISSUE，定义时传入的6个参数意义如下：</p>
<ul>
<li><code>LogUtilsNotUseds</code>: 我们这条lint规则的id，这个id必须是独一无二的。  </li>
<li><code>You must use our &#39;LogUtils&#39;</code>：对这条lint规则的简短描述。</li>
<li><code>Logging should be avoided in production for security and performance reasons. Therefore, we created a LogUtils that wraps all our calls to Logger and disable them for release flavor.</code>：对这条lint规则更详细的解释。</li>
<li><code>Category.MESSAGES</code>：类别。</li>
<li><code>9</code>：优先级，必须在1到10之间。</li>
<li><code>Severity.ERROR</code>：严重程度。其他可用的严重程度还有FATAL、WARNING、INFORMATIONAL、IGNORE。</li>
<li><code>Implementation</code>：这是连接Detector与Scope的桥梁，其中Detector的功能是寻找issue，而scope定义了在什么范围内查找issue。在我们的例子中，我们需要在字节码级别分析用户有没有使用<code>android.util.Log</code>。</li>
</ul>
<p>这个类中针对字节码中的android/util/Log进行了检查，并在发现时报告LogUtilsNotUsed这个issue。你也可以在这个类中定义多个issue，然后在代码逻辑中（比如checkCall方法中）针对不同的情况，抛出不同的issue。也就是说，一个XXXDetector是可以报告多种issue的。<br>如果需要检测更多问题，你也可以定义更多的XXXDetector类。XXXDetector类可以有多个。</p>
<p>【4】在ljflintrules中新建一个MyIssueRegistry类，它继承自<code>IssueRegistry</code>。这个类用来注册我们自己定义了哪些issue，这样lint在检查代码时才知道要针对哪些issue进行检查。代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyIssueRegistry</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">IssueRegistry</span> &#123;</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public <span class="type">List</span>&lt;<span class="type">Issue</span>&gt; getIssues() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"!!!!!!!!!!!!! ljf MyIssueRegistry lint rules works"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Arrays</span>.asList(<span class="type">LoggerUsageDetector</span>.<span class="type">ISSUE</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类中只有一个方法，就是返回一个List，其中包含了我们自定义的所有issue。<br>这里我们为了能够在控制台中清楚的看到我们自定义的lint规则是否被调用了，所以打印了一行提示信息。    </p>
<p>【5】对于自定义lint生成的jar，我们必须在它的清单文件中指明它的主类。这里我们通过配置ljflintrules的build.gradle文件来完成这项工作：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">jar</span> &#123;</span><br><span class="line">    <span class="literal">manifest</span> &#123;</span><br><span class="line">        attributes(<span class="string">'Lint-Registry'</span>: <span class="string">'com.ljf.lintrules.MyIssueRegistry'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，你可以在控制台中通过命令<code>./gradlew ljflintrules:assemble</code>来执行编译任务，就可以输出我们需要的jar文件了。你可以在ljflintrules工程目录的<code>build/libs/</code>下找到ljflintrules.jar。  </p>
<p>如果你想验证这个jar文件是不是真的有效，可以把它拷贝到<code>~/.android/lint/</code>目录下，然后在终端中输入<code>lint --show LogUtilsNotUsed</code>看看有没有输出我们定义的issue信息，有则表明自定义lint成功，如图：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-8/27617933.jpg" alt=""></p>
<p>测试完后记得把它从<code>~/.android/lint/</code>中删除。</p>
<p>【6】由于我们要把上一步生成的jar文件包含到一个aar中便于用户使用，所以我们还要在ljflintrules的build.gradle文件中添加以下信息：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">configurations</span> &#123;</span><br><span class="line">    <span class="title">lintJarOutput</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="title">lintJarOutput</span> files(jar)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defaultTasks <span class="string">'assemble'</span></span><br></pre></td></tr></table></figure>
<p>经过以上所有步骤，现在ljflintrules的build.gradle文件看起来是这样的：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.tools.lint:lint-api:24.3.1'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.tools.lint:lint-checks:24.3.1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes(<span class="string">'Lint-Registry'</span>: <span class="string">'com.ljf.lintrules.MyIssueRegistry'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">configurations</span> &#123;</span><br><span class="line">    lintJarOutput</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    lintJarOutput files(jar)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defaultTasks <span class="string">'assemble'</span></span><br></pre></td></tr></table></figure>
<p>【7】新建一个Android Library项目，命名为ljflintrule_aar，用来输出aar，步骤如下：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-7/98524820.jpg" alt=""></p>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-8/8544219.jpg" alt=""></p>
<p>在ljflintrule_aar的build.gradle的根节点加入以下内容：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * rules for including "lint.jar" in aar</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">configurations</span> &#123;</span><br><span class="line">    lintJarImport</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    lintJarImport <span class="keyword">project</span>(path: <span class="string">":ljflintrules"</span>, configuration: <span class="string">"lintJarOutput"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> copyLintJar(type: <span class="keyword">Copy</span>) &#123;</span><br><span class="line">    <span class="keyword">from</span> (<span class="keyword">configurations</span>.lintJarImport) &#123;</span><br><span class="line">        rename &#123;</span><br><span class="line">            String fileName -&gt;</span><br><span class="line">                <span class="string">'lint.jar'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">into</span> <span class="string">'build/intermediates/lint/'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>.afterEvaluate &#123;</span><br><span class="line">    <span class="keyword">def</span> compileLintTask = <span class="keyword">project</span>.tasks.<span class="keyword">find</span> &#123; it.name == <span class="string">'compileLint'</span> &#125;</span><br><span class="line">    compileLintTask.dependsOn(copyLintJar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这时再编译项目，就会在ljflintrule_aar的输出目录中得到一个包含lint.jar的aar文件，这里的lint.jar就是我们在第5步中生成的ljflintrules.jar，只是换了个名字。</p>
<p>【8】在用户app中使用我们的自定义lint。<br>在用户自己的应用程序module中（我们这里就使用app module），打开app的build.gradle文件，在dependencies中加入以下依赖：  </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="function"><span class="title">project</span><span class="params">(<span class="string">':ljflintrule_aar'</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>这里我们在app的MainActivity中使用了android自带的Log功能：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="type">Log</span>.d(<span class="string">"tag"</span>, <span class="string">"dasfadsf"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在终端中，我们执行<code>./gradlew lint</code>来执行lint任务，可以在终端中看到以下输出：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-8/11713429.jpg" alt=""></p>
<p>输出中指出发现了1个error和2个warning，并给出了详细报告的地址。</p>
<p>我们在浏览器中打开html格式的详细报告，如下图所示：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-8/9825338.jpg" alt=""></p>
<p>以上8个步骤完整演示了如何自定义lint并使用它。</p>
<h2 id="小结">小结</h2><p>本文对于自定义Lint规则的介绍主要是集中在总体开发流程，给出了一个简单的实例。在实际开发过程中，我们比较常见的需求是针对xml布局文件、java源代码等内容进行某些检查，受Lint开发API的限制需要用到AST的相关知识，以及lombok.ast开源库。由于lombok.ast开源库几乎无文档可用，所以还是需要花一定时间来阅读这个库的源码，并熟悉SDK自带的Lint源码如何使用这个库。如果你对自定义Lint感兴趣，可以关注下一篇文章的相关介绍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在做一个基于Android Lint的自定义静态代码检查功能库，这里做一个简单的总结。前半部分介绍SDK自带Android Lint的功能与配置使用方法，后半部分介绍扩展自定义Lint规则库的开发流程。</p>
<h2 id="什么是Android_Lint">什么是Android Lint</h2><p>Android Lint是一个静态代码分析工具，它能够对你的Android项目中潜在的bug、可优化的代码、安全性、性能、可用性、可访问性、国际化等进行检查。  </p>
<p>在Android SDK Tools 16及更高的版本中，Lint工具会自动安装。通过它对Android工程源代码进行扫描和检查，可发现潜在的问题，以便程序员及早修正这个问题。Android Lint提供了命令行方式执行，还与IDE（如Android Studio）进行了集成，并提供了xml和html形式的输出报告。  </p>
<p>看了上面的介绍可能大家依然很迷惑“这货到底有啥用”，其实我们平时在Android开发过程中一直在享受Lint带来的便利。比如，下面图中的警告和错误提示，相信大家应该很熟悉吧：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-1-29/23031672.jpg" alt=""></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.carrotsight.com/tags/Android/"/>
    
      <category term="Lint" scheme="http://www.carrotsight.com/tags/Lint/"/>
    
      <category term="custom lint rules" scheme="http://www.carrotsight.com/tags/custom-lint-rules/"/>
    
      <category term="Android" scheme="http://www.carrotsight.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可缩放时间轴和录像片段选择器的实现]]></title>
    <link href="http://www.carrotsight.com/2015/12/09/%E5%8F%AF%E7%BC%A9%E6%94%BE%E6%97%B6%E9%97%B4%E8%BD%B4%E5%92%8C%E5%BD%95%E5%83%8F%E7%89%87%E6%AE%B5%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <id>http://www.carrotsight.com/2015/12/09/可缩放时间轴和录像片段选择器的实现.html</id>
    <published>2015-12-09T06:53:40.000Z</published>
    <updated>2016-02-01T03:45:04.000Z</updated>
    <content type="html"><![CDATA[<p>最近的工作是做了两个自定义控件：<br>①可以缩放的时间轴<br>②吸附在在时间轴上有两个滑动按钮的录像片段选择器  </p>
<p>真机测试效果如下面的gif动画所示：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-10/74682253.jpg" alt=""></p>
<a id="more"></a>
<p>在此记录一下设计原理和踩过的坑。</p>
<h2 id="时间轴">时间轴</h2><p>时间轴分为两部分轴，刻度轴和录像片段轴。刻度轴用来绘制时间刻度表盘，录像片段轴用来指示对应位置有没有录像存在。<br>时间轴的视觉效果如下：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-9/11028878.jpg" alt=""></p>
<p>其中下面有时间标注的刻度部分是刻度轴，上面灰色背景一段一段绿色的部分是录像片段轴，如下图的标注所示：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-9/86365109.jpg" alt=""></p>
<h3 id="刻度轴">刻度轴</h3><p>刻度轴的起始时间点、终止时间点、跨越长度、当前滑动到的时间点（即屏幕中间的游标指示的时间）都可以根据传入参数定制。刻度分为大刻度（关键刻度）和小刻度，大刻度要显示刻度和对应的时间文字，小刻度只显示刻度。刻度分为6档，根据缩放级别的不同（用户双指缩放或界面按钮缩放），把刻度打到不同位置。<br>比如，刚进入界面时刻度轴的刻度以默认档位显示，要在如图的位置打出刻度：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-9/12666172.jpg" alt="刻度轴1"></p>
<p>当用户双指在屏幕上拉伸，或点击放大按钮，导致时间轴被放大时，一开始刻度打印方式不变（依然在这几个时刻打印文字），只是刻度间的距离随手指的拉伸距离而逐渐变大。当刻度间距离达到一定程度时，刻度打印方式改变，变成如下图的刻度样式：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-9/53994347.jpg" alt="刻度轴2"></p>
<p>当用户双指在屏幕上收缩，或点击缩小按钮，导致时间轴被缩小时，一开始刻度打印方式不变（依然在这几个时刻打印文字），只是刻度间的距离随手指的收缩距离而逐渐变小。当刻度间距离小到一定程度时，刻度打印方式改变，变成如下图的刻度样式：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-9/78534287.jpg" alt="刻度轴3"></p>
<p>我的实现方式是，通过继承view实现一个自定义view，在onMeasure（）阶段把view宽度设置成所有刻度都绘制出来会占用的长度，即包括超出屏幕的实际长度。由于游标实际是不移动的，游标指示时间的改变是通过刻度轴的反向滑动来实现的，所以为了在时间轴滑动到尽头时游标能够指示到刻度轴尽头的时间，还需要在用户指定的长度基础上，在刻度轴的最左端和最右端分别额外增加屏幕一半宽度的空白区。原理图如下：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-9/73909141.jpg" alt=""></p>
<h4 id="刻度档位信息">刻度档位信息</h4><p>由于刻度轴根据缩放级别的不同，有6档不同的刻度显示方式（上面展示了3种），所以先把6档刻度信息写进map缓存，map中的每一个item记录这档刻度以下信息：</p>
<ul>
<li>一屏幕总共要显示的秒数（即可见区域包含的秒数）</li>
<li>大刻度对应的秒数</li>
<li>小刻度对应的秒数</li>
<li>关键刻度文字的显示模式（DataFormat的pattern）</li>
</ul>
<p>比如刻度轴1对应的这几个值就是6 <em> 60 </em> 60（一屏幕总共显示6个小时长度）、60 <em> 60（大刻度对应的都是整小时，即60 </em> 60的整数倍）、5 * 60（小刻度对应的都是5分钟的整数倍）、”HH:mm”（时间文字显示小时和分钟）。</p>
<p>然后，利用手机屏幕宽度screenWidth、用户指定的刻度轴总长度WHOLE_TIMEBAR_TOTAL_SECONDS、以及刚刚在map中设定的一屏幕总共要显示的秒数totalSecondsInOneScreen，就可以计算出某个刻度档位的时间轴总长度（像素）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewLength = (<span class="keyword">int</span>) ((<span class="keyword">float</span>) screenWidth * WHOLE_TIMEBAR_TOTAL_SECONDS / (<span class="keyword">float</span>) totalSecondsInOneScreen);</span><br></pre></td></tr></table></figure><br>把算出的这个viewLength也缓存到map的对应item中，作为某一档的默认view宽度。</p>
<h4 id="view宽度设定">view宽度设定</h4><p>在view第一次被初始化时，我们默认把刻度轴的样式设定在第3档的刻度样式，那么就从map中取出对应的刻度档位信息的时间轴总长度字段viewLength，然后通过为view指定新的LayoutParams来指定时间轴view控件的宽度，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ViewGroup.LayoutParams params = getLayoutParams();</span><br><span class="line">params.width = viewLength;</span><br><span class="line">setLayoutParams(params);</span><br></pre></td></tr></table></figure></p>
<p>这样仅仅是把view宽度指定为有刻度的部分的总长度。为了加上view两端无刻度的留白部分，我们要在onMeasure方法中做一些手脚：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;       </span><br><span class="line">       setMeasuredDimension(measureWidth(widthMeasureSpec), VIEW_HEIGHT);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * 计算时间轴的宽度，左右都预留半个屏幕的宽度    </span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">measureWidth</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> measureMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">       <span class="keyword">int</span> measureSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">       <span class="keyword">int</span> result = getSuggestedMinimumWidth();</span><br><span class="line">       <span class="keyword">switch</span> (measureMode) &#123;</span><br><span class="line">           <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">           <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">               result = measureSize + screenWidth;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>这样的话，手机在测量view尺寸的时候就会把多出来的一个屏幕的宽度也算进去。</p>
<h4 id="画刻度onDraw()">画刻度onDraw()</h4><p>刻度怎么画是刻度轴实现的关键。思路是，我们在onDraw（）中只绘制出屏幕上可见的那一部分，每次用户滑动或缩放时间轴，都通过invalidate()来重新回调onDraw（）方法。  那么关键问题就是如何确定屏幕可见部分在view中的起始点、终止点分别是第几个像素。  </p>
<p>不管时间轴view被用户缩放到了什么长度，它的总长度我们总是知道的（因为之所以能看到缩放效果，就是我们手动利用缩放指数factor计算新的长度，然后在onMeasure中重新手动赋值，后面会讲到），同时整个时间轴的跨度有多少秒我们也是知道的（用户需要通过参数指定view的起点、终点时间，类型为long），那么我们就可以计算出一秒钟对应多少个像素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pixelsPerSecond = (<span class="keyword">float</span>) (getWidth() - screenWidth) / (<span class="keyword">float</span>) WHOLE_TIMEBAR_TOTAL_SECONDS;</span><br></pre></td></tr></table></figure></p>
<p>由于用户在初始化时还指定了希望游标指示在哪个时刻上currentTimeInMillisecond，同时我们再利用这一档刻度标准规定的最小刻度间的时间间隔minTickInSecond（在第一部初始化map时指定），我们就可以求出屏幕可见区域最左端、最右端对应的是时间轴上的哪个时刻：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> forStartUTC = (<span class="keyword">long</span>) (currentTimeInMillisecond / <span class="number">1000</span> - screenWidth / pixelsPerSecond / <span class="number">2</span> - minTickInSecond);</span><br><span class="line"><span class="keyword">long</span> endStartUTC = (<span class="keyword">long</span>) (currentTimeInMillisecond / <span class="number">1000</span> + screenWidth / pixelsPerSecond / <span class="number">2</span> + minTickInSecond);</span><br></pre></td></tr></table></figure></p>
<p>虽然我们知道了屏幕两端对应的时刻，但由于这个时刻很可能是不能被最小刻度间距minTickInSecond整除的，比如我们的最小刻度是5秒一档，但是当前最左端是12：05：02，那么这个地方就不应该打刻度，而应该继续往后早到第一个能被minTickInSecond整除的位置。  </p>
<p>这里就有一个大坑。如果直接去用求模运算（%）找第一个刻度点，就会导致手机调整不同时区时，刻度被打在不同位置上的问题，比如我希望00：00、06：00、12：00、18：00才作为关键刻度打印时间文字，但是手机时区跳到北京时间（UTC+8)时，刻度会被打在08：00、14：00、20：00、02：00这几个位置上。更糟糕的是，当缩放到关键刻度只打印年月日而不打印时间的级别时，看起来游标指在2015-12-09的位置上，用户会以为这是北京时间2015-12-09 00：00：00，而实际他指向的是北京时间2015-12-09 08：00：00。  </p>
<p>要解决这个问题，就要在找刻度、画刻度的时候考虑手机设定时区与UTC的时差，用UTC时间加上时差的结果来计算刻度的位置，但是时间轴上每个点代表的时间仍然是UTC时间，打印关键刻度文字传给DataFormatter的参数也仍然是UTC时间，因为DataFormat我们在默认不指定时区的情况下就是把UTC时间转成手机设定的本地时区时间来显示的。找屏幕要画出的第一个刻度的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">       *找出当前屏幕要画出的第一个刻度对应的时刻</span><br><span class="line">       */</span></span><br><span class="line">      Calendar cal = Calendar.getInstance();</span><br><span class="line">      <span class="keyword">int</span> zoneOffsetInSeconds = cal.get(java.util.Calendar.ZONE_OFFSET) / <span class="number">1000</span>;<span class="comment">//手机本地时区与UTC相差的毫秒数</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> forStartUTC = (<span class="keyword">long</span>) (currentTimeInMillisecond / <span class="number">1000</span> - screenWidth / pixelsPerSecond / <span class="number">2</span> - timebarTickCriterionMap.get(currentTimebarTickCriterionIndex).minTickInSecond);</span><br><span class="line">      <span class="keyword">long</span> endStartUTC = (<span class="keyword">long</span>) (currentTimeInMillisecond / <span class="number">1000</span> + screenWidth / pixelsPerSecond / <span class="number">2</span> + timebarTickCriterionMap.get(currentTimebarTickCriterionIndex).minTickInSecond);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> forStartLocalTimezone = forStartUTC + zoneOffsetInSeconds;</span><br><span class="line">      <span class="keyword">long</span> endStartLocalTimezone = endStartUTC + zoneOffsetInSeconds;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> firstTickToSeeInSecondUTC = -<span class="number">1</span>;<span class="comment">//屏幕上能看到的最左边一个刻度对应的时间,单位是秒</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">long</span> i = forStartLocalTimezone; i &lt;= endStartLocalTimezone; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i % timebarTickCriterionMap.get(currentTimebarTickCriterionIndex).minTickInSecond == <span class="number">0</span>) &#123;</span><br><span class="line">              firstTickToSeeInSecondUTC = i - zoneOffsetInSeconds;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>timebarTickCriterionMap.get(currentTimebarTickCriterionIndex).minTickInSecond</code>就是用来取到当前刻度档位的最小刻度时间间距。<br>这里为了避免最边缘的第一个和最后一个刻度绘制不出来，所以在forStartUTC和endStartUTC里都多给了一个最小刻度的余量，也就是代码第7行和第8行最后加减的一个最小刻度间距minTickInSecond。<br>这样，我们就找到了在本次onDraw（）时，我们需要从view的第几个像素开始画刻度（view最左端的位置为第0个像素，大部分之间可能在屏幕之外很远的地方）。</p>
<p>然后从firstTickToSeeInSecondUTC的位置开始，以minTickInSecond为步进值，找每一个时刻，把每一个刻度也加上本地与UTC的时差，然后去对关键刻度间距keyTickInSecond和小刻度间距minTickInSecond分别求模运算（%），能被keyTickInSecond整除的就是关键刻度，只能被minTickInSecond整除的就是小刻度。如此，再调用canvas.drawRect()、canvas.drawText(）分别画刻度和文字。</p>
<h4 id="双指缩放">双指缩放</h4><p>用户在触摸屏上双指缩放或点击放大、缩小按钮时，时间轴要产生缩放效果，原理很简单，就是拿缩放比例scaleFactor乘以当前整个个view宽度（不含一屏幕的空白区）最为新的宽度，然后拿这个宽度和每一档刻度标准中view整体长度字段进行比较，在合适的位置进行档位切换，或者在算出view宽度过大或过小时进行限制。总之，就是算出一个新的view宽度值，然后重设view的LayoutParams，onMeasure（）和onDraw（），就可以看到缩放效果了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">   * 按照比例对时间轴进行缩放</span><br><span class="line">   * <span class="doctag">@param</span> scaleFactor 缩放比例</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scaleTimebarByFactor</span><span class="params">(<span class="keyword">float</span> scaleFactor)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> newWidth = (<span class="keyword">int</span>) ((getWidth() - screenWidth) * scaleFactor);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newWidth &gt; timebarTickCriterionMap.get(<span class="number">0</span>).viewLength) &#123;</span><br><span class="line">          setCurrentTimebarTickCriterionIndex(<span class="number">0</span>);</span><br><span class="line">          newWidth = timebarTickCriterionMap.get(<span class="number">0</span>).viewLength;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newWidth &lt; timebarTickCriterionMap.get(<span class="number">0</span>).viewLength</span><br><span class="line">              &amp;&amp; newWidth &gt;= getAverageWidthForTwoCriterion(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">          setCurrentTimebarTickCriterionIndex(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newWidth &lt; getAverageWidthForTwoCriterion(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">              &amp;&amp; newWidth &gt;= getAverageWidthForTwoCriterion(<span class="number">1</span>, <span class="number">2</span>)) &#123;</span><br><span class="line">          setCurrentTimebarTickCriterionIndex(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newWidth &lt; getAverageWidthForTwoCriterion(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">              &amp;&amp; newWidth &gt;= getAverageWidthForTwoCriterion(<span class="number">2</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">          setCurrentTimebarTickCriterionIndex(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newWidth &lt; getAverageWidthForTwoCriterion(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">              &amp;&amp; newWidth &gt;= getAverageWidthForTwoCriterion(<span class="number">3</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">          setCurrentTimebarTickCriterionIndex(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newWidth &lt; getAverageWidthForTwoCriterion(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">              &amp;&amp; newWidth &gt;= timebarTickCriterionMap.get(<span class="number">4</span>).viewLength) &#123;</span><br><span class="line">          setCurrentTimebarTickCriterionIndex(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newWidth &lt; timebarTickCriterionMap.get(<span class="number">4</span>).viewLength) &#123;</span><br><span class="line">          setCurrentTimebarTickCriterionIndex(<span class="number">4</span>);</span><br><span class="line">          newWidth = timebarTickCriterionMap.get(<span class="number">4</span>).viewLength;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ViewGroup.LayoutParams params = getLayoutParams();</span><br><span class="line">      params.width = newWidth;</span><br><span class="line">      setLayoutParams(params);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="录像片段轴">录像片段轴</h3><p>录像片段轴的绘制原理很简单，就是拿到一个List数据源，其中的每一个item都有录像片段的开始时间from、结束之间end，我们就通过换算，得到每个片段对应的开始像素位置、结束像素位置，然后在屏幕的对应位置用canvas.drawRect()画框就行了。<br>但是考虑到效率问题，如果录像片段数据很多，达到数千甚至数万段（比如很多都是短视频），那么一次性全部绘制出来是不现实的，还是只能绘制屏幕可见部分，然后在时间轴被缩放时，录像片段轴随之缩放，回调onDraw（）方法，再次重绘屏幕可见区域。<br>问题就来了，在保证List中数据片段不重叠（即每一段的from到to与另一段的from到to都无交集）且有序排列的情况下（前一段的to小于后一段的from），如何快速找到哪一个item才是第一个应该被绘制出来的item？遍历list的方法显然太耗时，每次onDraw（）都去遍历一遍的话，界面在滑动或缩放时会卡顿得无法接受。  </p>
<p>我的解决办法如下：<br><strong>步骤一</strong>：在外界向view设置录像片段轴的数据源List后，用我自己的类CloudRecordExistTimeClips来记录录像片段item信息，其中包括from、to的long值，还包括一个List字段<code>coverDateZeroOClockList</code>用来记录这个item跨越了哪几天，也就是<br>从startTimeInMillisecond到endTimeInMillisecond所涵盖的所有日期的00：00所对应的毫秒数。比如从2015-11-26 10:10:30到2015-11-29 19：12：55，那么coverDateZeroOClockList就记录“2015-11-26 00：00：00”、“2015-11-27 00：00：00”、“2015-11-28 00：00：00”、“2015-11-29 00：00：00”。具体实现方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudRecordExistTimeClips</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">long</span> mostLeftDayZeroTime = Long.MAX_VALUE;<span class="comment">//所有时间片段最早的开始日期对应的00：00的毫秒数</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">long</span> mostRightDayZeroTime = -<span class="number">1</span>;<span class="comment">//所有时间片段最晚的开始日期对应的00：00的毫秒数</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">long</span> startTimeInMillisecond;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">long</span> endTimeInMillisecond;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span><br><span class="line">        * 从startTimeInMillisecond到endTimeInMillisecond所涵盖的所有日期的00：00所对应的毫秒数。</span><br><span class="line">        * 如从2015-11-26 10:10:30到2015-11-29 19：12：55，</span><br><span class="line">        * 那么coverDateZeroOClockList就记录“2015-11-26 00：00：00”、“2015-11-27 00：00：00”、“2015-11-28 00：00：00”、“2015-11-29 00：00：00”</span><br><span class="line">        */</span></span><br><span class="line">       <span class="keyword">private</span> List&lt;Long&gt; coverDateZeroOClockList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">CloudRecordExistTimeClips</span><span class="params">(<span class="keyword">long</span> startTimeInMillisecond, <span class="keyword">long</span> endTimeInMillisecond)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.startTimeInMillisecond = startTimeInMillisecond;</span><br><span class="line">           <span class="keyword">this</span>.endTimeInMillisecond = endTimeInMillisecond;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (startTimeInMillisecond &lt; mostLeftDayZeroTime)&#123;</span><br><span class="line">               <span class="keyword">this</span>.mostLeftDayZeroTime = startTimeInMillisecond;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (endTimeInMillisecond &gt; mostRightDayZeroTime)&#123;</span><br><span class="line">               <span class="keyword">this</span>.mostRightDayZeroTime = endTimeInMillisecond;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">           SimpleDateFormat zeroTimeFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">           String startTimeDateString = dateFormat.format(startTimeInMillisecond);</span><br><span class="line">           String startTimeZeroTimeString = startTimeDateString + <span class="string">" 00:00:00"</span>;</span><br><span class="line"></span><br><span class="line">           String endTimeDateString = dateFormat.format(endTimeInMillisecond);</span><br><span class="line">           String endTimeZeroTimeString = endTimeDateString + <span class="string">" 00:00:00"</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Date startTimeZeroDate = zeroTimeFormat.parse(startTimeZeroTimeString);</span><br><span class="line">               Date endTimeZeroDate = zeroTimeFormat.parse(endTimeZeroTimeString);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">long</span> loopZeroDateInMilliseconds = startTimeZeroDate.getTime();</span><br><span class="line">               <span class="keyword">while</span> (loopZeroDateInMilliseconds &lt;= endTimeZeroDate.getTime())&#123;</span><br><span class="line">                   coverDateZeroOClockList.add(loopZeroDateInMilliseconds);</span><br><span class="line">                   loopZeroDateInMilliseconds = loopZeroDateInMilliseconds + SECONDS_PER_DAY * <span class="number">1000</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStartTimeInMillisecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> startTimeInMillisecond;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getEndTimeInMillisecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> endTimeInMillisecond;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> List&lt;Long&gt; <span class="title">getCoverDateZeroOClockList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> coverDateZeroOClockList;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤二</strong>：根据每个录像片段对象CloudRecordExistTimeClips覆盖的日期，将每一个item缓存在一个全局Map中，map的key是某个日期00：00：00对应的long，value就是这个片段CloudRecordExistTimeClips对象。比如，一个片段的from是<code>2015-12-08 11:32:22</code>，to值是<code>2015-12-10 11:32:22</code>，那么这个对象就同时处在key为<code>2015-12-08 00:00:00</code>、<code>2015-12-09 00:00:00</code>、<code>2015-12-10 00:00:00</code>的map槽中。</p>
<p><strong>步骤三</strong>：在onDraw（）方法中，我们知道屏幕可见区域左边缘与view的交点对应的时间轴UTC时间（比如<code>2015-12-09 15:30:12</code>），那么我们就以当天0点的时间（即例子的<code>2015-12-09 00：00：00</code>）为key去取出当天第一个片段，从这个片段画起。如果这个key对应的values为null，那么就把key的值往后加一天，继续找，找到找到第一个片段开始画；或者key的时间大于屏幕右边缘的时间还没找到就停止寻找，因为说明屏幕可见区域中没有需要绘制的录像片段。</p>
<h3 id="滑动与缩放">滑动与缩放</h3><p>缩放事件毫无疑问直接使用android提供的缩放手势探测器ScaleGestureDetector来检测，直接可以拿到缩放比例参数scaleFactor，然后用上面提到的缩放函数来处理。<br>滑动可以在<code>onTouchEvent（MotionEvent event）</code>中自己处理ACTION_DOWN、ACTION_MOVE、ACTION_UP事件流，也可以直接使用android提供的手势探测器GestureDetector来处理，拿到滑动的距离deltaX，在原来view的layout位置的基础上计算滑动后应该处于的位置，然后调用layout(left, top, right, top + getHeight())来使view滑动，最后调用invalidate()来发起重绘。</p>
<p><strong>这里踩到一个坑</strong>：<br>ScaleGestureDetector和GestureDetector都要在<code>onTouchEvent（MotionEvent event）</code>函数的最前面通过截获event来进行手势处理。如果是一个缩放事件，ScaleGestureDetector已经处理了缩放手势，那么ACTION_DOWN、ACTION_MOVE、ACTION_UP以及其他事件流就不应该再继续在onTouchEvent（）后面的ACTION_DOWN、ACTION_MOVE、ACTION_UP等分支中处理了，按照android文档说明，我使用<code>scaleGestureDetector.onTouchEvent(event)</code>的返回值来判断这个event是不是已近被处理过的缩放事件，如果是就直接return不再走后面的流程。<br>结果证明我很傻很天真，时间轴在被我双指缩放时同时也出现了意外的位移，说明scaleGestureDetector.onTouchEvent(event)的返回值是无效的。<br>google之后发现，很多开发者都遇到了同样的问题，说这应该是android sdk的一个bug，scaleGestureDetector.onTouchEvent(event)永远只会返回false。所以，在这里要先通过<code>scaleGestureDetector.onTouchEvent(event)</code>调用缩放手势探测器，然后用<code>scaleGestureDetector.isInProgress()</code>来判断本次事件是否被作为缩放手势处理了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123; </span><br><span class="line">       scaleGestureDetector.onTouchEvent(event);</span><br><span class="line">       <span class="keyword">if</span> (scaleGestureDetector.isInProgress()) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">switch</span> (event.getAction() &amp; MotionEvent.ACTION_MASK) &#123;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">               ...</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          </span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">               ...</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">              	...</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="录像片段选择器">录像片段选择器</h2><p>通过两个滑动按钮来选择录像片段，两个滑动按钮之间的部分表示被选中的片段，两个滑动按钮上要显示对应的录像截图、时间文字提示，在滑动时、静止时根据获取成功与否显示不同的占位图。由于录像片段选择器上的时间信息是依附于时间轴控件的，所以当时间轴被滑动、缩放时，录像片段选择器也要同步更新。</p>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-10/52392486.jpg" alt=""></p>
<p>很明显，这个控件简化一下就是有两个thumb的seekbar，所以就取github上找了一下两个按钮的seekbar控件，结果找到了<a href="https://github.com/yahoo/android-range-seek-bar" target="_blank" rel="external">anothem/android-range-seek-bar项目</a>，它提供与android的seekbar视觉效果类似的双按钮seekbar控件。<br>我的改造工作主要就是重写onMeasure()、onLayout()、onDraw()、onTouchEvent()方法，最麻烦的就是onDraw（）中绘制时对绝对坐标的计算。其计算方法与时间轴类似，甚至还简单许多，这里就不再重复写了。</p>
<p><em>这里的一个坑</em>：<br>由于这个自定义view中需要用到android的ImageView（给Glide使用），所以这个自定义view就不能继承于<code>view</code>，而是继承于<code>ViewGroup</code>，这样就可以在初始化阶段向其中添加其他view了。然而调试的时候发现，<code>onDraw（）</code>方法怎么都不会被调用。原来，ViewGroup默认只是用来布局，一般没有什么需要绘制的东西，所以系统默认就不调用它的onDraw（）回调。如果要让ViewGroup的onDraw（）方法被回调，有两种方法：  </p>
<p>【方法1】让系统知道这个ViewGroup有可绘制的东西，比如在xml中定义这个ViewGroup的时候为它指定background属性。<br>【方法2】在代码中调用setWillNotDraw(false)强制要求调用onDraw()方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近的工作是做了两个自定义控件：<br>①可以缩放的时间轴<br>②吸附在在时间轴上有两个滑动按钮的录像片段选择器  </p>
<p>真机测试效果如下面的gif动画所示：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-10/74682253.jpg" alt=""></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.carrotsight.com/tags/Android/"/>
    
      <category term="时间轴" scheme="http://www.carrotsight.com/tags/%E6%97%B6%E9%97%B4%E8%BD%B4/"/>
    
      <category term="Android" scheme="http://www.carrotsight.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个android日志库的实现]]></title>
    <link href="http://www.carrotsight.com/2015/11/13/%E4%B8%80%E4%B8%AAandroid%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
    <id>http://www.carrotsight.com/2015/11/13/一个android日志库的实现.html</id>
    <published>2015-11-13T06:12:58.000Z</published>
    <updated>2015-12-04T10:45:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="调研">调研</h1><p>在android开发中，如果需要打印调试信息，往往会使用Log.d()、Log.e()之类的由android.util.Log提供的方法。它的好处是简单、方便，不足也很明显，可定制性差，不能打印到文件。如果想在发行版app中的某些关键语句打印log到文件，或者在app崩溃时把崩溃信息打印到文件供上传分析，那么android.util.Log就无能为力了。<br><a id="more"></a><br>在网上做了一下android平台日志库的调研，挑出一些比较有代表性有影响力的，大致结果如下：</p>
<blockquote>
<p>①orhanobut/logger：<br>来自github.com，截止2015年11月10日15:53:20该项目已经有1996颗星！！！<br>地址：<a href="https://github.com/orhanobut/logger" target="_blank" rel="external">https://github.com/orhanobut/logger</a></p>
<p>②JakeWharton/timber：<br>来自github.com，截止2015年11月10日15:54:22该项目已经有1571颗星！！！<br>地址：<a href="https://github.com/JakeWharton/timber" target="_blank" rel="external">https://github.com/JakeWharton/timber</a></p>
<p>③noveogroup/android-logger：<br>来自github.com，截止2015年11月10日15:55:56该项目已经有125颗星（跟上面两位比差的挺多）。<br>地址：<a href="https://github.com/noveogroup/android-logger" target="_blank" rel="external">https://github.com/noveogroup/android-logger</a></p>
<p>④SLF4J：<br>它只是一个对log系统进行抽象的表现形式，不是具体的实现。它支持第三方log框架，比如log4j等。如果需要指定第三方log框架，只需要在运行时把对应的slf4j的jar文件放在你的class path中，系统会自动bind该log框架。比如，要从java.util.logging中切换到log4j，只需要把slf4j-jdk-1.7.12.jar替换为slf4j-log4j12-1.7.12.jar即可。<br>地址：<a href="http://www.slf4j.org/download.html" target="_blank" rel="external">http://www.slf4j.org/download.html</a></p>
<p>⑤SLF4J-Android：<br>SLF4J-Android是对SLF4J的API的重新包装，以及一个轻量级的bind实现。该实现简单的把所有的SLF4J的log请求都用Android的Log工具进行了替换。功能与SLF4J类似。不过只支持23个字符长度的Tag，例如com.example.myapp.MyClass会被截断为c*.e*.m*.MyClass，会导致不同的类在tag中显示同样的名称，引起混淆。<br>地址：<a href="http://www.slf4j.org/android/" target="_blank" rel="external">http://www.slf4j.org/android/</a></p>
<p>⑥ LOGBack：<br>LOGBack与Log4J的作者是同一个人。作者更推荐使用LOGBack。具作者说LOGBack在某些苛刻的执行路径下，比log4j差不多要快10倍，经过了长期而广泛的测试，比log4j更为可靠。不过这货是个重量级选手，功能太全，体积庞大。<br>地址：<a href="http://logback.qos.ch/" target="_blank" rel="external">http://logback.qos.ch/</a></p>
<p>⑦android-logging-log4j：<br>内部使用log4j，支持slf4j;适用于log4j的LogCatAppender，它能够把log打印到LogCat;提供了一个log4j的配置装饰类，用它能够方便地配置Log4J;同时不需要修改log4j.jar文件。<br>地址：<a href="https://code.google.com/p/android-logging-log4j/" target="_blank" rel="external">https://code.google.com/p/android-logging-log4j/</a></p>
</blockquote>
<p>前三个库是专为android设计的，可以看到支持者众多，不过它们内部实现上也是调用android.util.Log的方法打印到控制台，不能满足我们的需求。后面的几个库中有一些选手非常全能，不过体积较大，很多功能是我们不需要的，而且它也无法很方便的扩展自定义的日志实现，比如app崩溃信息获取、日志文件后台上传等。于是乎开始自己动手实现一个既方便实用，能覆盖基本的控制台、文件输出，又便于自定义扩展的android日志库。</p>
<h1 id="gradle直接配置日志库">gradle直接配置日志库</h1><p>log4j最强大方便的地方应该就是它可以直接通过property文件进行配置。这里由于我们实用Android Studio进行开发，所以希望能够直接通过build.gradle文件对我们的日志库进行配置。在网上搜索了良久，发现可以在buildTypes中分别为debug版本和release版本（甚至更多其他自定义版本）定义不同的buildConfigField参数，然后在java代码中通过自动生成的BuildConfig文件进行读取。</p>
<p>例如，我在module的build.grade文件中做了如下配置：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Logger settings for release mode</span></span><br><span class="line">            <span class="comment">//以下是配置MyLog打印功能的各项参数</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"logLevel"</span>, <span class="string">"\"VERBOSE\""</span>)<span class="comment">//设置当前log的打印级别。支持的打印级别分别为：VERBOSE,DEBUG,INFO,WARN,ERROR,ASSERT。与logcat的级别一一对应。只有等于或高于此级别的log才会被打印出来。</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"logToSDDirName"</span>, <span class="string">"\"MyLogs-release\""</span>)<span class="comment">//如果设置了打印到文件，则此字段指定把日志打印到SD卡的哪个目录</span></span><br><span class="line">            buildConfigField(<span class="string">"int"</span>, <span class="string">"singleLogFileSizeLimit"</span>, <span class="string">"10"</span>)<span class="comment">//如果设置了打印到文件，则此字段设置单个log文件的大小上限，单位是MB</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            <span class="comment">//Logger settings for debug mode</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"logLevel"</span>, <span class="string">"\"DEBUG\""</span>)<span class="comment">//设置当前log的打印级别。支持的打印级别分别为：VERBOSE,DEBUG,INFO,WARN,ERROR,ASSERT。与logcat的级别一一对应。只有等于或高于此级别的log才会被打印出来。</span></span><br><span class="line">            buildConfigField(<span class="string">"String"</span>, <span class="string">"logToSDDirName"</span>, <span class="string">"\"MyLogs-debug\""</span>)<span class="comment">//如果设置了打印到文件，则此字段指定把日志打印到SD卡的哪个目录</span></span><br><span class="line">            buildConfigField(<span class="string">"int"</span>, <span class="string">"singleLogFileSizeLimit"</span>, <span class="string">"10"</span>)<span class="comment">//如果设置了打印到文件，则此字段设置单个log文件的大小上限，单位是MB</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么就可以在对应module的java代码中进行读取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = BuildConfig.logMethodDepth;</span><br></pre></td></tr></table></figure>
<p>这个方案并没有问题，不过接下来却踩进了一个坑，因为我下意识的把这些配置都写在了我的Log库module中，同样，对配置参数（如logMethodDepth等）的读取也是在Log库module的java代码中。这样就带来两个问题，也是后来才意识到的：</p>
<ul>
<li>坑①：<br>Gradle目前有一个bug：你在库项目的build.gradle中定义了release和debug两种配置，然后不论你的Build Variants是选择debug还是release，默认都只会编译release版本。在stackoverflow上搜索后发现好几年前就已经有人在提这个问题了，不过直到日前在android开发者网站上仍然把这个问题列为希望在将来解决的问题。不过这个问题后来通过一个比较绕的方法解决了，就是在Log库module的build.gradle中加入defaultPublishConfig配置，变成这样：</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果要使用buildTypes中debug版的log配置，则设置为debug；否则，设置为release</span></span><br><span class="line">        defaultPublishConfig <span class="string">"debug"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以指定是使用debug版还是release版的配置了。不过这样的库提供给用户也够麻烦的，因为用户不仅要设置自己app的buildType，还得每次手动来设置Log库module的编译type，搞不好一不小心两者设的不统一就麻烦了。</p>
<ul>
<li>坑②：<br>如果以这样的方式来配置Log库，那么用户就只能以module源码的方式将Log库引入自己的工程。如果要把Log库打成aar包提供给用户怎么办？参数就没法自定义了吧。</li>
</ul>
<p>所以，醒悟后就把对Log库的自定义配置参数从Log库的build.gradle移动到了用户app的build.gradle中，也就是在readme.md文件中说明使用方法，其中一步就是要用户与把示例代码拷贝到自己app的build.gradle中，在对Log进行初始化时进行配置参数的调用。当然，这里Log初始化的代码也是在说明文件中写好的，用户拷贝即可。</p>
<h1 id="日志写入到文件">日志写入到文件</h1><p>要实现把日志写入到sd的指定目录下，日志文件按照日期进行自动命名，每个日志文件要限制大小，达到文件大小上限后自动创建新的文件，等等。于是又google了良久，发现可以用java.util.logging.FileHandler配合java.util.logging.logger来实现。<br>要使用FileHandler，先要实现一个自己的Formatter类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFormatter</span> <span class="keyword">extends</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">        String appPackageName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyFormatter</span><span class="params">(String appPackageName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.appPackageName = appPackageName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">(LogRecord rec)</span> </span>&#123;</span><br><span class="line">            StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">            SimpleDateFormat timeFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">            buf.append(timeFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            buf.append(<span class="string">'/'</span>);</span><br><span class="line">            buf.append(appPackageName);</span><br><span class="line">            buf.append(<span class="string">' '</span>);</span><br><span class="line">            buf.append(MYLogLevel.getSimpleLevelStringByJavaLevel(rec.getLevel()));</span><br><span class="line">            buf.append(<span class="string">'/'</span>);</span><br><span class="line">            buf.append(rec.getParameters()[<span class="number">0</span>]);</span><br><span class="line">            buf.append(<span class="string">':'</span>);</span><br><span class="line">            buf.append(<span class="string">' '</span>);</span><br><span class="line">            buf.append(formatMessage(rec));</span><br><span class="line">            buf.append(<span class="string">'\n'</span>);</span><br><span class="line">            <span class="keyword">return</span> buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   
<p>然后，创建一个FileHandler实例，并把MyFormatter的一个实例作为参数传给我们的FileHandler实例，并用FileHandler来作为我们的Logger的处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;                                                                                                                                        </span><br><span class="line">		Logger logger = Logger.getLogger(packageName);                                                                                       </span><br><span class="line">		logger.setUseParentHandlers(<span class="keyword">false</span>);                                                                                                  </span><br><span class="line">                                                                                                                                             </span><br><span class="line">		SimpleDateFormat dateformat1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);                                                                   </span><br><span class="line">		String datestring = dateformat1.format(<span class="keyword">new</span> Date());                                                                                  </span><br><span class="line">		fh = <span class="keyword">new</span> FileHandler(file.getAbsolutePath() + <span class="string">"_"</span> + datestring + <span class="string">"_%g"</span> + <span class="string">".log"</span>,                                                     </span><br><span class="line">				singleLogFileSizeLimit * <span class="number">1024</span> * <span class="number">1024</span>, <span class="number">9999</span>, <span class="keyword">true</span>);                                                                           </span><br><span class="line">		fh.setFormatter(<span class="keyword">new</span> MyFormatter(packageName));                                                                                       </span><br><span class="line">		logger.addHandler(fh);                                                                                                               </span><br><span class="line">                                                                                                                                             </span><br><span class="line">		<span class="keyword">return</span> logger;                                                                                                                       </span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;                                                                                                                </span><br><span class="line">		e.printStackTrace();                                                                                                                 </span><br><span class="line">		<span class="keyword">if</span> (fh != <span class="keyword">null</span>) &#123;                                                                                                                    </span><br><span class="line">			fh.close();                                                                                                                      </span><br><span class="line">		&#125;                                                                                                                                    </span><br><span class="line">                                                                                                                                             </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;                                                                                                                         </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>关于FileHandler实例化的参数，官网说明如下：</p>
<blockquote>
<p>public class FileHandler<br>extends StreamHandler<br>Simple file logging Handler.<br>The FileHandler can either write to a specified file, or it can write to a rotating set of files.<br>For a rotating set of files, as each file reaches a given size limit, it is closed, rotated out, and a new file opened. Successively older files are named by adding “0”, “1”, “2”, etc. into the base filename.<br>By default buffering is enabled in the IO libraries but each log record is flushed out when it is complete.<br>By default the XMLFormatter class is used for formatting.<br>Configuration: By default each FileHandler is initialized using the following LogManager configuration properties. If properties are not defined (or have invalid values) then the specified default values are used.<br>java.util.logging.FileHandler.level specifies the default level for the Handler (defaults to Level.ALL).<br>java.util.logging.FileHandler.filter specifies the name of a Filter class to use (defaults to no Filter).<br>java.util.logging.FileHandler.formatter specifies the name of a Formatter class to use (defaults to java.util.logging.XMLFormatter)<br>java.util.logging.FileHandler.encoding the name of the character set encoding to use (defaults to the default platform encoding).<br>java.util.logging.FileHandler.limit specifies an approximate maximum amount to write (in bytes) to any one file. If this is zero, then there is no limit. (Defaults to no limit).<br>java.util.logging.FileHandler.count specifies how many output files to cycle through (defaults to 1).<br>java.util.logging.FileHandler.pattern specifies a pattern for generating the output file name. See below for details. (Defaults to “%h/java%u.log”).<br>java.util.logging.FileHandler.append specifies whether the FileHandler should append onto any existing files (defaults to false).<br>A pattern consists of a string that includes the following special components that will be replaced at runtime:<br>“/“ the local pathname separator<br>“%t” the system temporary directory<br>“%h” the value of the “user.home” system property<br>“%g” the generation number to distinguish rotated logs<br>“%u” a unique number to resolve conflicts<br>“%%” translates to a single percent sign “%”<br>If no “%g” field has been specified and the file count is greater than one, then the generation number will be added to the end of the generated filename, after a dot.<br>Thus for example a pattern of “%t/java%g.log” with a count of 2 would typically cause log files to be written on Solaris to /var/tmp/java0.log and /var/tmp/java1.log whereas on Windows 95 they would be typically written to C:\TEMP\java0.log and C:\TEMP\java1.log<br>Generation numbers follow the sequence 0, 1, 2, etc.<br>Normally the “%u” unique field is set to 0. However, if the FileHandler tries to open the filename and finds the file is currently in use by another process it will increment the unique number field and try again. This will be repeated until FileHandler finds a file name that is not currently in use. If there is a conflict and no “%u” field has been specified, it will be added at the end of the filename after a dot. (This will be after any automatically added generation number.)<br>Thus if three processes were all trying to log to fred%u.%g.txt then they might end up using fred0.0.txt, fred1.0.txt, fred2.0.txt as the first file in their rotating sequences.<br>Note that the use of unique ids to avoid conflicts is only guaranteed to work reliably when using a local disk file system.</p>
</blockquote>
<h1 id="配置日志库服务">配置日志库服务</h1><p>我们希望日志库能够根据用户需求，把log打印到控制台、或者输出到SD卡的文件，或者在某些条件下把SD的日志文件上传到服务器，那么就需要以service的形式来提供日志库的功能。</p>
<p>大体的架构设计，就是把日志库service跑在一个独立的进程中，提供一个wrapper类供用户调用，对于日志库servcie的任何调用都对用户是透明的，用户只需要像使用android自带的Log工具那样使用.d()、.e()方法就可以了。每个app在自己的Application类中调用日志库wrappe类的初始化函数，在这一步传入app自己的相关信息如包名等，日志库会根据包名生成对应的日志文件。service中开一个新线程，里面显示地启动一个looper，外界发来的打印log的请求都被以消息的形式传递给这个新线程的消息队列来处理。</p>
<p>Thread的run方法大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Log.VERBOSE:</span><br><span class="line">                        printToFile(msg, <span class="string">"VERBOSE"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Log.DEBUG:</span><br><span class="line">                        printToFile(msg, <span class="string">"DEBUG"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Log.INFO:</span><br><span class="line">                        printToFile(msg, <span class="string">"INFO"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Log.WARN:</span><br><span class="line">                        printToFile(msg, <span class="string">"WARN"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Log.ERROR:</span><br><span class="line">                        printToFile(msg, <span class="string">"ERROR"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Log.ASSERT:</span><br><span class="line">                        printToFile(msg, <span class="string">"ASSERT"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始servcie的工作线程是在orhanobut/logger之上做扩展，对于wrapper类的实现是使用AIDL，在app调用wrapper的初始化函数时，wrapper自动bind到日志库service，然后再通过AIDL调用service的初始化以及打印log的方法（这些对用户app都是透明的）。这里就遇到一个大坑：</p>
<p>如果以显示Intent的方法来启动servcie，就会发现把日志库以module源码的形式提供给app使用是没有问题的，但是如果打成aar包提供给app使用，就会出现bind失败，很奇怪。</p>
<p>如果以隐式Intent的方法来启动service，打成aar包也可以正常启动servie，但是由于android 5.0以上要求必须以显示Intent启动service，故这种方法的覆盖范围太小。</p>
<p>后来大神review了我的代码，说最好不要用AIDL，因为那样会一直在app和servcie之间保持一个长连接，没有必要。可以直接用start方法启动servcie，用intent来传递请求参数，也是一样的。再加上我写的第一版是以log4j的形式，虽然提供了gradle的参数配置日志库的各项功能，但是功能是写死的，无法扩展，如果用户有一些个性化的日志需求就没法用我这个东西。</p>
<p>所以后来就对代码进行了重构，改为在JakeWharton/timber之上扩展，我提供一个日志框架，以及两个日志工具（打印到控制台、打印到文件），用户也可以继承我的日志工具基类实现自己的日志工具。用户在自己的app中，根据业务需求，在初始化时选择一个或多个日志工具安装到框架，具体的打印请求也是同android默认日志工具一样直接.d()、.e()这样调用，很方便。</p>
<p>这里记一下踩到的另外几个坑，有些比较低级😓：<br>1、一开始之所以选择在orhanobut/logger上扩展，是因为它默认提供了非常美观的打印格式，以及线程信息、日志调用栈信息。后来突然反应过来，我提供的库虽然会与用户app打进同一个apk，wrapper也是与用户app跑在同一线程，但是真正的日志打印工作是在service的单独进程中完成的，那么它默认提供的调用栈信息就无意义了。  </p>
<p>2、AIDL是同步调用，而service的所有其它接口（bind, unbind, startService, stopService）都是异步接口，立即返回。参考：<a href="http://blog.csdn.net/edisonlg/article/details/7164761）。" target="_blank" rel="external">http://blog.csdn.net/edisonlg/article/details/7164761）。</a>  </p>
<p>3、在调试时发现初始化貌似很耗时，跟踪了一下，发现new FileHandler()这一操作居然要耗时30~40ms!!!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="调研">调研</h1><p>在android开发中，如果需要打印调试信息，往往会使用Log.d()、Log.e()之类的由android.util.Log提供的方法。它的好处是简单、方便，不足也很明显，可定制性差，不能打印到文件。如果想在发行版app中的某些关键语句打印log到文件，或者在app崩溃时把崩溃信息打印到文件供上传分析，那么android.util.Log就无能为力了。<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.carrotsight.com/tags/Android/"/>
    
      <category term="库项目" scheme="http://www.carrotsight.com/tags/%E5%BA%93%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="日志" scheme="http://www.carrotsight.com/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="Android" scheme="http://www.carrotsight.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FlatBuffers学习总结]]></title>
    <link href="http://www.carrotsight.com/2015/10/10/FlatBuffers%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html"/>
    <id>http://www.carrotsight.com/2015/10/10/FlatBuffers学习总结.html</id>
    <published>2015-10-10T13:37:08.000Z</published>
    <updated>2015-12-03T08:41:07.000Z</updated>
    <content type="html"><![CDATA[<p>据说facebook使用google的黑科技flatbuffers，用来替代传统的json进行数据交换，大大提高了facebook android客户端的效率。于是我在网上查找各种资料学习了一下flatbuffers，参看资料包括GOOGLE官方文档、facebook技术博客、以及其他国内的个人博客，也写了些代码做实验，以此文作为学习总结。</p>
<h2 id="什么是Google_FlatBuffers">什么是Google FlatBuffers</h2><p>FlatBuffers是一个开源的、跨平台的、高效的、提供了C++/Java接口的序列化工具库。它是Google专门为游戏开发或其他性能敏感的应用程序需求而创建。尤其更适用于移动平台，这些平台上内存大小及带宽相比桌面系统都是受限的，而应用程序比如游戏又有更高的性能要求。它将序列化数据存储在缓存中，这些数据既可以存储在文件中，又可以通过网络原样传输，而不需要任何解析开销。<br><a id="more"></a></p>
<h2 id="为什么要使用Google_FlatBuffers">为什么要使用Google FlatBuffers</h2><ol>
<li>对序列化数据的访问不需要打包和拆包——它将序列化数据存储在缓存中，这些数据既可以存储在文件中，又可以通过网络原样传输，而没有任何解析开销；  </li>
<li>内存效率和速度——访问数据时的唯一内存需求就是缓冲区，不需要额外的内存分配；   </li>
<li>扩展性、灵活性——它支持的可选字段意味着不仅能获得很好的前向/后向兼容性（对于长生命周期的游戏来说尤其重要，因为不需要每个新版本都更新所有数据）；  </li>
<li>最小代码依赖——仅仅需要自动生成的少量代码和一个单一的头文件依赖，很容易集成到现有系统中。  </li>
<li>强类型设计——尽可能使错误出现在编译期，而不是等到运行期才手动检查和修正；</li>
<li>使用简单——生成的C++代码提供了简单的访问和构造接口；而且如果需要，通过一个可选功能可以用来在运行时高效解析Schema和类JSON格式的文本；</li>
<li>跨平台——支持C++11、Java，而不需要任何依赖库；在最新的gcc、clang、vs2010等编译器上工作良好。  </li>
</ol>
<p>官网的基准测试结果如下图所示：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/屏幕快照%202015-09-30%20下午3.08.24.png" alt=""></p>
<h2 id="为什么不使用Protocol_Buffers或者JSON">为什么不使用Protocol Buffers或者JSON</h2><h3 id="Protocol_Buffers_vs_FlatBuffers">Protocol Buffers vs FlatBuffers</h3><p>Protocol Buffers的确和FlatBuffers比较类似，但其主要区别在于FlatBuffers在访问数据前不需要解析/拆包这一步，而且Protocol Buffers没有可选的文本导入/导出功能（FlatBuffers可以直接根据Schema和json文本生成对应的二进制数据文件）。<br>Protocol Buffers使用一些特殊的数据结构来存储数据，从而在解析数据时需要花费额外的时间。比如，使用varints来存储整型数，varints是一种使用一个或多个字节来序列化整型数的方法，越小的数占用的字节数就越少。同时，代表一个数字的多个字节采用little endian的方式来存储。这就导致在解析数据时，需要判断哪几个字节是表示这个字段的，并进行其他的数学变换来还原出原始数据。<br>关于protocal buffers具体的数据编码方式，可以参考<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="external">google开发者网站</a>以及<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-gpb/" target="_blank" rel="external">IBM技术博客</a>。  </p>
<p>与之相对，FlatBuffers可以直接根据起始位置+偏移量直接获取到数据，无解析过程，效率更高，而伴随的副作用是FlatBuffers需要占用相对更多的空间，因为Protocol Buffers的编码在一定程度上压缩了数据。</p>
<p>网上有人进行了性能对比试验，结果如下图：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-10-10/60479922.jpg" alt=""></p>
<h3 id="JSON_vs_FlatBuffers">JSON vs FlatBuffers</h3><p>JSON是非常可读的，而且当和动态类型语言（如JavaScript）一起使用时非常方便。然而在静态类型语言中序列化数据时，JSON不但具有运行效率低的明显缺点，而且会让你写更多的代码来访问数据（这个与直觉相反）。</p>
<h2 id="哪些项目使用了FlatBuffers">哪些项目使用了FlatBuffers</h2><ul>
<li><strong>Cocos2d-x</strong>, the #1 open source mobile game engine, uses it to serialize all their game data.</li>
<li><strong>Facebook</strong> uses it for client-server communication in their Android app. They have a nice article explaining how it speeds up loading their posts.</li>
<li><strong>Fun Propulsion Labs</strong> at Google uses it extensively in all their libraries and games.</li>
</ul>
<h2 id="FlatBuffers原理">FlatBuffers原理</h2><p>假设我们有一个person类，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> friendshipStatus;</span><br><span class="line">    Person spouse;</span><br><span class="line">    List&lt;Person&gt;friends;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的spouse和friends字段页包含了person对象，这样就形成了一个树结构。下面就是关于此对象在FlatBuffer中存储的简化图示：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-10-8/13378046.jpg" alt=""></p>
<p>从图中可以看到：</p>
<ul>
<li>每个对象都被分成两部分：中心点左边的元数据部分（或者叫vtable），和中心点右边的真实数据部分。</li>
<li>每个字段都对应vtable中的一个槽（slot），它存储了那个字段的真实数据的偏移量。例如，John的vtable的第一个槽的值是1，表明John的名字被存储在John的中心点右边的一个字节的位置上。</li>
<li>如果一个字段是一个对象，那么它在vtable中的偏移量会指向子对象的中心点（pivot point）。比如，John的vtable中第三个槽指向Mary的中心点。</li>
<li>要表明某个字段现在没有数据，可以在vtable对应的槽中使用偏移量0来标注。</li>
</ul>
<p>要了解更复杂的关于FlatBuffers字段修改的实现原理，可以查看<a href="https://code.facebook.com/posts/872547912839369/improving-facebook-s-performance-on-android-with-flatbuffers/" target="_blank" rel="external">facebook的文档</a>中的“Mutation on FlatBuffers”部分。</p>
<h2 id="简明使用步骤">简明使用步骤</h2><ol>
<li>编写一个用来定义你想序列化的数据的schema文件（又称IDL），数据类型可以是各种大小的int、float，或者是string、array，或者另一对象的引用，甚至是对象集合。各个数据属性都是可选的，且可以设置默认值,所以不必要为每个对象实例都去呈现这些字段。  </li>
<li>使用FlatBuffer编译器flatc生成C++头文件或者Java类，生成的代码里额外提供了访问、构造序列化数据的辅助类。生成的代码仅仅依赖flatbuffers.h；  </li>
<li>使用FlatBufferBuilder类构造一个二进制buffer。你可以向这个buffer里循环添加各种对象，而且很简单，就是一个单一函数调用；</li>
<li>保存或者发送该buffer；</li>
<li>当再次读取该buffer时，你可以得到这个buffer根对象的指针，然后就可以简单的就地读取数据内容。</li>
</ol>
<h2 id="FlatBuffers使用实战">FlatBuffers使用实战</h2><h3 id="构建flatc(FlatBuffers编译器)">构建flatc(FlatBuffers编译器)</h3><p>从<a href="https://github.com/google/flatbuffers" target="_blank" rel="external">Google的flatbuffers仓库</a>下载或克隆源代码,可以在<a href="https://google.github.io/flatbuffers/md__building.html" target="_blank" rel="external">Google的FlatBuffers构建文档中</a>查看构建过程。如果你是Mac用户的话就可以直接按照下面的步骤来操作：  </p>
<ol>
<li>打开下载的源代码，目录是<code>\{extract directory}\build\Xcode\FlatBuffers.xcodeproj</code> ，用Xcode打开此文件。   </li>
<li>点击<code>Play</code>按钮或者<code>⌘ + R</code>运行。  </li>
<li>flatc可执行文件会出现在项目的根目录下。<br>现在就可以使用flatc来从给定的schema生成模型类，或者把JSON转换成FlatBuffers二进制文件了。</li>
</ol>
<h3 id="编写一个Schema">编写一个Schema</h3><p>Schema语言（即IDL）的语法与C语言家族很类似。一个简单的例子如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example IDL file</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyGame;</span><br><span class="line"></span><br><span class="line">attribute <span class="string">"priority"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color : byte &#123; Red = <span class="number">1</span>, Green, Blue &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> Any &#123; Monster, Weapon, Pickup &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Vec3 &#123;</span><br><span class="line">  x:<span class="keyword">float</span>;</span><br><span class="line">  y:<span class="keyword">float</span>;</span><br><span class="line">  z:<span class="keyword">float</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table Monster &#123;</span><br><span class="line">  pos:Vec3;</span><br><span class="line">  mana:<span class="keyword">short</span> = <span class="number">150</span>;</span><br><span class="line">  hp:<span class="keyword">short</span> = <span class="number">100</span>;</span><br><span class="line">  name:<span class="built_in">string</span>;</span><br><span class="line">  friendly:<span class="keyword">bool</span> = <span class="literal">false</span> (deprecated, priority: <span class="number">1</span>);</span><br><span class="line">  inventory:[ubyte];</span><br><span class="line">  color:Color = Blue;</span><br><span class="line">  test:Any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root_type Monster;</span><br></pre></td></tr></table></figure>
<p>（Weapon 和 Pickup没有在这个例子中列出。）</p>
<h4 id="Tables">Tables</h4><p>Tables是在FlatBuffers中定义对象的主要方式，由名字（这里的Monster）和字段列表组成。每一个字段都有名字、类型、和一个可选的默认值（如果忽略的话，默认是0/NULL）。<br><strong>每一个字段都是可选的</strong>：对每一个单独的对象个体，你都可以选择忽略一些字段。也就使你可以灵活的增加字段，而不必担心数据膨胀。这个设计也是FlatBuffers向前和向后兼容的机制。<br><strong>注意：</strong>  </p>
<ul>
<li>如果要在schema中添加新字段，只能在table的末尾进行添加。</li>
<li>如果你不再使用某些字段了，你不能从schema中删除它们。你可以不再把它们写入到你的数据中，效果是一样的。  </li>
</ul>
<h4 id="Structs">Structs</h4><p>Structs与Table类似，只不过没有字段是可选的了(所以没有默认值了)，并且字段不能增加或被废弃（deprecated）。Struct只能包含标量或者其他struct。如果你<strong>非常确定</strong>任何变化都不会发生，那么就可以使用struct。Struct使用的内存比table少，并且读取时比table更快（它们通常被以in-line的方式存储在它们的父对象中，并且不适用virtual table）。</p>
<h4 id="类型">类型</h4><p>内建的标量类型：  </p>
<blockquote>
<ul>
<li>8 bit: byte ubyte bool</li>
<li>16 bit: short ushort</li>
<li>32 bit: int uint float</li>
<li>64 bit: long ulong double</li>
</ul>
</blockquote>
<p>内建的非标量类型：  </p>
<blockquote>
<ul>
<li>关于任何其他类型的Vector</li>
<li>string，只能存储UTF-8或者7-bit ASCII。如果需要存储其他编码的文本，或者通用二进制数据，请使用vector（[byte]或者[ubyte]）。</li>
<li>对其他table、struct、enum或者union的引用。</li>
</ul>
</blockquote>
<p>关于编写Schema的更多信息，可以参考<a href="https://google.github.io/flatbuffers/md__schemas.html" target="_blank" rel="external">Google文档：Writing a aschema</a>。</p>
<p>在实验中，我直接使用网上的示例文件。<br>要处理的数据对应的JSON文件的下载地址为：<a href="https://github.com/frogermcs/FlatBuffs/blob/master/flatbuffers/repos_json.json" target="_blank" rel="external">https://github.com/frogermcs/FlatBuffs/blob/master/flatbuffers/repos_json.json</a>    </p>
<p>这个JSON的结构如下面的片段所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "repos": [</span><br><span class="line">    &#123;</span><br><span class="line">      "id": 27149168,</span><br><span class="line">      "name": "acai",</span><br><span class="line">      "full_name": "google/acai",</span><br><span class="line">      "owner": &#123;</span><br><span class="line">        "login": "google",</span><br><span class="line">        "id": 1342004,</span><br><span class="line">        ...</span><br><span class="line">        "type": "Organization",</span><br><span class="line">        "site_admin": false</span><br><span class="line">      &#125;,</span><br><span class="line">      "private": false,</span><br><span class="line">      "html_url": "https://github.com/google/acai",</span><br><span class="line">      "description": "Testing library for JUnit4 and Guice.",</span><br><span class="line">      ...</span><br><span class="line">      "watchers": 21,</span><br><span class="line">      "default_branch": "master"</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用FlatBuffers处理这个JSON数据，我们需要编写对应的Schema，在这个例子中需要创建3个Table：<code>ReposList</code>, <code>Repo</code> 和 <code>User</code>，还要定义<code>root_type</code>。  </p>
<p>可以直接从github下载已经编写好的Schema，地址为<a href="https://github.com/frogermcs/FlatBuffs/blob/master/flatbuffers/repos_schema.fbs" target="_blank" rel="external">https://github.com/frogermcs/FlatBuffs/blob/master/flatbuffers/repos_schema.fbs</a>。<br>这个Schema的部分片段如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">table ReposList &#123;</span><br><span class="line">    repos : [Repo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table Repo &#123;</span><br><span class="line">    id : <span class="keyword">long</span>;</span><br><span class="line">    name : <span class="built_in">string</span>;</span><br><span class="line">    full_name : <span class="built_in">string</span>;</span><br><span class="line">    owner : User;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    labels_url : <span class="built_in">string</span> (deprecated);</span><br><span class="line">    releases_url : <span class="built_in">string</span> (deprecated);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table User &#123;</span><br><span class="line">    login : <span class="built_in">string</span>;</span><br><span class="line">    id : <span class="keyword">long</span>;</span><br><span class="line">    avatar_url : <span class="built_in">string</span>;</span><br><span class="line">    gravatar_id : <span class="built_in">string</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    site_admin : <span class="keyword">bool</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root_type ReposList;</span><br></pre></td></tr></table></figure>
<h3 id="FlatBuffers数据文件">FlatBuffers数据文件</h3><p>现在我们要做的就是把JSON文件转换成FlatBuffers二进制文件，并且生成能够以JAVA友好方式表达我们的数据的JAVA模型。方法是在中断中执行以下命令：<br><code>$ ./flatc -j -b repos_schema.fbs repos_json.json</code></p>
<p>如果一切运行正常，会看到一系列新生成的文件，它们分别是：</p>
<ul>
<li>repos_json.bin (我们把它重命名为repos_flat.bin)</li>
<li>Repos/Repo.java</li>
<li>Repos/ReposList.java</li>
<li>Repos/User.java</li>
</ul>
<p>Schema编译器(即flatc)的完整使用方法为：  </p>
<blockquote>
<p>flatc [ -c ] [ -j ] [ -b ] [ -t ] [ -o PATH ] [ -I PATH ] [ -S ] FILES…<br>      [ – FILES…]  </p>
</blockquote>
<p>具体参数说明可以在<a href="https://google.github.io/flatbuffers/md__compiler.html" target="_blank" rel="external">Google说明文档</a>查看。</p>
<h3 id="在Android_app中读数据">在Android app中读数据</h3><p>在Android Studio中使用FlatBuffers，需要把repos_flat.bin放到res/raw/目录下，同时把<code>repo.java</code>, <code>ReposList.java</code> 和 <code>User.java</code>放到工程源代码的某个目录下。  </p>
<p>FlatBuffers提供java库来直接在java中操纵这种数据格式。从<a href="https://github.com/frogermcs/FlatBuffs/blob/master/app/libs/flatbuffers-java-1.2.0-SNAPSHOT.jar" target="_blank" rel="external">这里</a>下载jar文件（也可以自己下载的latBuffers源代码，用mvn生成这个库文件），把它放在Android工程的app/libs/目录下。  </p>
<p>在需要读取FlatBuffers数据的地方，先把bin文件读取到一个byte数组中，然后用如下所示的代码访问各数据字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer bb = ByteBuffer.wrap(dataByteArray);</span><br><span class="line">ReposList rootRoposList = ReposList.getRootAsReposList(bb);</span><br><span class="line">Log.i(<span class="string">"TAG"</span>, <span class="string">"reposLength = "</span> + rootRoposList.reposLength());</span><br><span class="line">Repo repo1 = rootRoposList.repos(<span class="number">0</span>);</span><br><span class="line">Log.i(<span class="string">"TAG"</span>, <span class="string">"id: "</span> + repo1.id() + <span class="string">"\nname: "</span> + repo1.name() + <span class="string">"\nforks: "</span> + repo1.forks());</span><br></pre></td></tr></table></figure>
<p>第一行代码中传入的参数dataByteArray就是从bin文件读出的二进制byte数组。</p>
<p><em>注意：</em><br>Java不支持无符号标量。这意味着你在schema中使用的任何无符号类型实际上都会被表达成为一个有符号的值。这表明，所有的bit都仍然在，但可能代表一个负数。比如，要把一个<code>byte b</code>作为一个无符号数来读取，可以这样做：<code>(short)(b &amp; 0xFF)</code>。</p>
<h3 id="在Android_app中写数据（以FlatBuffers格式传输数据）">在Android app中写数据（以FlatBuffers格式传输数据）</h3><p>先创建Builder：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlatBufferBuilder fbb = <span class="keyword">new</span> FlatBufferBuilder();</span><br></pre></td></tr></table></figure>
<p>创建String字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> str = fbb.createString(<span class="string">"MyMonster"</span>);</span><br></pre></td></tr></table></figure>
<p>创建一个包含struct的table：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Monster.startMonster(fbb);</span><br><span class="line">Monster.addPos(fbb, Vec3.createVec3(fbb, <span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">3.0</span>, (<span class="keyword">byte</span>)<span class="number">4</span>, (<span class="keyword">short</span>)<span class="number">5</span>, (<span class="keyword">byte</span>)<span class="number">6</span>));</span><br><span class="line">Monster.addHp(fbb, (<span class="keyword">short</span>)<span class="number">80</span>);</span><br><span class="line">Monster.addName(fbb, str);</span><br><span class="line">Monster.addInventory(fbb, inv);</span><br><span class="line">Monster.addTest_type(fbb, (<span class="keyword">byte</span>)<span class="number">1</span>);</span><br><span class="line">Monster.addTest(fbb, mon2);</span><br><span class="line">Monster.addTest4(fbb, test4s);</span><br><span class="line"><span class="keyword">int</span> mon = Monster.endMonster(fbb);</span><br></pre></td></tr></table></figure>
<p>最后，需要终止这个buffer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Monster.finishMonsterBuffer(fbb, mon);</span><br></pre></td></tr></table></figure>
<p>这个buffer现在已经可以被传输了。它被包含在ByteBuffer中，可以通过fbb.dataBuffer()来获取。很重要的一点是，buffer中有效的数据不是从偏移量0开始的，而是从fbb.dataBuffer().position()开始的，在fbb.dataBuffer().capacity()结束。</p>
<p>更详细的java使用方法，可以参见<a href="https://google.github.io/flatbuffers/md__java_usage.html" target="_blank" rel="external">google官方文档</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>据说facebook使用google的黑科技flatbuffers，用来替代传统的json进行数据交换，大大提高了facebook android客户端的效率。于是我在网上查找各种资料学习了一下flatbuffers，参看资料包括GOOGLE官方文档、facebook技术博客、以及其他国内的个人博客，也写了些代码做实验，以此文作为学习总结。</p>
<h2 id="什么是Google_FlatBuffers">什么是Google FlatBuffers</h2><p>FlatBuffers是一个开源的、跨平台的、高效的、提供了C++/Java接口的序列化工具库。它是Google专门为游戏开发或其他性能敏感的应用程序需求而创建。尤其更适用于移动平台，这些平台上内存大小及带宽相比桌面系统都是受限的，而应用程序比如游戏又有更高的性能要求。它将序列化数据存储在缓存中，这些数据既可以存储在文件中，又可以通过网络原样传输，而不需要任何解析开销。<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.carrotsight.com/tags/Android/"/>
    
      <category term="FlatBuffers" scheme="http://www.carrotsight.com/tags/FlatBuffers/"/>
    
      <category term="Google" scheme="http://www.carrotsight.com/tags/Google/"/>
    
      <category term="facebook" scheme="http://www.carrotsight.com/tags/facebook/"/>
    
      <category term="Android" scheme="http://www.carrotsight.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android编程要注意的安全规范]]></title>
    <link href="http://www.carrotsight.com/2015/09/19/2015-9-19-Android%E7%BC%96%E7%A8%8B%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%AE%89%E5%85%A8%E8%A7%84%E8%8C%83.html"/>
    <id>http://www.carrotsight.com/2015/09/19/2015-9-19-Android编程要注意的安全规范.html</id>
    <published>2015-09-19T11:46:08.000Z</published>
    <updated>2015-12-03T08:08:03.000Z</updated>
    <content type="html"><![CDATA[<p>这两天阅读了一下android developer网站与安全相关的部分，对android编程过程中主要注意的安全细节进行了学习，在此总结一下要点。</p>
<h2 id="Android框架自身的安全性机制">Android框架自身的安全性机制</h2><ol>
<li>Android应用程序沙盒，把每个app的数据与代码都分隔开。  </li>
<li>对各种安全功能进行了强健实现的应用程序框架，如密码学、权限、安全IPC等。  </li>
<li>加密的文件系统，它能够保护丢失或被盗设备的数据。  </li>
<li>用户能够授权权限来限制对系统和用户数据的访问。  </li>
<li>应用程序定义的权限。<a id="more"></a>
<h2 id="数据存储">数据存储</h2><h3 id="使用内部存储">使用内部存储</h3></li>
<li>默认情况下，你在内部存储上创建的文件只能被该app本身访问。  </li>
<li>应该尽量避免在IPC文件上使用 MODE_WORLD_WRITEABLE或MODE_WORLD_READABLE模式。如果实在需要数据共享，应该使用content provider。  </li>
<li>对于敏感数据，应该选择一个密钥对本地文件进行加密，这个密钥应该不能直接被应用程序访问。比如，把密钥保存在KeyStore中，并且用一个不存储在该设备上的用户密码来保护它。</li>
</ol>
<h3 id="使用扩展存储">使用扩展存储</h3><ol>
<li>扩展存储（如SD卡）上的文件是全局可读写的（被其他应用程序）。不要在扩展存储上存放敏感信息。  </li>
<li>处理扩展存储上的数据前最好进行输入验证。</li>
</ol>
<h3 id="使用content_providers">使用content providers</h3><ol>
<li>如果不打算让其他应用程序访问你的ContentProvider，就在manifest文件中用<code>android:exported=false</code>来标记它。  </li>
<li>如果创建的ContentProvider需要被提供给其他应用程序使用，可以特别指定单独的读权限和写权限。  </li>
<li>如果使用ContentProvider只是在你自己的几个app之间共享数据，那么最好把<code>android:protectionLevel</code>属性设置为<code>&quot;signature&quot;</code>。  </li>
<li>可以对content provider提供更细粒度的访问控制，如使用<code>android:grantUriPermissions</code>属性，在Intent对象中使用<code>FLAG_GRANT_READ_URI_PERMISSION</code>和<code>FLAG_GRANT_WRITE_URI_PERMISSION</code>标记。  </li>
<li>在访问content provider时，使用参数化查询方法如query()、update()、delete()等来避免潜在的SQL注入风险。但这仍有风险，比如selection参数是通过之前用户提交的数据连接而成的。  </li>
<li>不要对写权限的安全性产生错觉。比如，如果写权限允许写SQL语句，那么WHERE字句巧妙地构造就可以使得“写权限”等价于“读写权限”。</li>
</ol>
<h2 id="使用权限">使用权限</h2><h3 id="请求权限">请求权限</h3><ol>
<li>请求最少数量的权限，如果一个权限对你的app来说不是必须的，就不要请求。  </li>
<li>完全有可能用一种方法不请求任何权限，比如为了创建独一无二的标示符可以使用GUID而不是请求设备信息，可以把数据存储在内部存储（无须权限）而不是存储在扩展存储（需要权限）。  </li>
<li>推荐尽可能使用访问控制，而不是用户确认的权限，因为权限可能让用户疑惑。</li>
<li>不要泄露有权限保护的数据。</li>
</ol>
<h3 id="创建权限">创建权限</h3><p>这种情况很少见，因为系统定义的权限已近覆盖了大部分的需求。<br>如果必须创建新权限，考虑是否可以用<code>&quot;signature&quot;</code>级别的<code>protection level</code>来实现。</p>
<h2 id="使用网络">使用网络</h2><h3 id="使用IP网络">使用IP网络</h3><ol>
<li>确保对于敏感信息使用合适的协议，比如HttpsURLConnection。如果服务器支持的话，我们更倾向于使用HTTPS而不是HTTP，因为移动设备频繁的连接在不安全的网络中，比如公共Wi-Fi热点。  </li>
<li>认证的加密的套接字级别的会话，可以很容易地用SSLSocket类来实现。  </li>
<li>有些引用程序使用localhost网络端口来处理敏感的IPC，这种做法应该避免，因为其他应用程序也能够访问到这些接口。应该使用具有授权控制的Android IPC机制比如Service。</li>
<li>所有通过HTTP协议或其他不安全协议获取到的数据都是不可信任的，要做好数据验证工作。</li>
</ol>
<h3 id="使用电话网络">使用电话网络</h3><p>SMS协议的设计本就不适合app传输数据。不管是在网络上还是设备上，SMS既没有加密也没有强壮的认证。在Android设备上，SMS消息是以广播形式传输的，所以它们可以被所有其他具有<code>READ_SMS</code>权限的应用程序读取或捕获。  </p>
<h2 id="使用WebView">使用WebView</h2><ol>
<li>如果你的应用程序不直接通过webview使用JavaScript，那么就不要调用<code>setJavaScriptEnabled()</code>。默认情况下webview是不执行JavaScript的，这样就可以防止跨站脚本攻击。  </li>
<li>只把<code>addJavaScriptInterface()</code>暴露给具有可信输入的网页。  </li>
<li>如果你的应用程序通过WebView访问敏感数据，你可以使用    <code>clearCache()</code>方法来删除任何存储在本地的文件。也可以使用服务器端的header比如<code>no-cache</code>来表明一个应用程序不应该缓存特定的内容。</li>
<li>用户名和密码不应该存储在设备上。初次认证的时候使用用户提供的用户名和密码，以后就使用一个短生命周期的、service特有的认证token。</li>
<li>被多个应用程序访问的Service应该使用AccountManager来访问。</li>
</ol>
<h2 id="使用密码学">使用密码学</h2><ol>
<li>如果需要安全地从已知位置获取一个文件，可以很简单地使用<code>HTTPS URI</code>。  </li>
<li>如果需要安全数据通道，考虑使用<code>HttpsURLConnection</code>或者<code>SSLSocket</code>，而不是去写一个你自己的协议。  </li>
<li>如果你真的需要实现自己的协议，也不要自己实现加密算法，可以直接只用存在的已实现的加密算法，比如<code>Cipher</code>类中的AES或者RSA算法。  </li>
<li>使用安全随机数生成器<code>SecureRandom</code>来初始化任何的密钥、<code>KeyGenerator</code>。使用非安全随机数生成器得到的密钥，会削弱算法的安全强度，也会导致离线攻击。</li>
<li>如果需要存储一个密钥来提供多次使用，应该使用诸如<code>KeyStore</code>之类的机制。  </li>
</ol>
<h2 id="使用IPC">使用IPC</h2><ol>
<li>不要使用传统Linux中的IPC技术比如网络套接字和共享文件等。应该使用Android系统提供的IPC功能比如Intent、与Service配合的Binder或者Messenger、BroadcastReceiver。Android的IPC机制允许你验证连接到你IPC的应用程序的身份，并且能够为每个IPC机制设置安全策略。  </li>
<li>如果你的IPC机制不打算给其他应用程序使用，可以在manifest清单中把<code>android:exported</code>属性设置为<code>false</code>。  </li>
</ol>
<hr>
<p>其他安全性相关问题，可以参考:<br>1、<a href="http://developer.android.com/training/best-security.html" target="_blank" rel="external">http://developer.android.com/training/best-security.html</a><br>2、<a href="https://www.owasp.org/index.php/OWASP_Mobile_Security_Project#tab=Secure_Mobile_Development" target="_blank" rel="external">https://www.owasp.org/index.php/OWASP_Mobile_Security_Project#tab=Secure_Mobile_Development</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两天阅读了一下android developer网站与安全相关的部分，对android编程过程中主要注意的安全细节进行了学习，在此总结一下要点。</p>
<h2 id="Android框架自身的安全性机制">Android框架自身的安全性机制</h2><ol>
<li>Android应用程序沙盒，把每个app的数据与代码都分隔开。  </li>
<li>对各种安全功能进行了强健实现的应用程序框架，如密码学、权限、安全IPC等。  </li>
<li>加密的文件系统，它能够保护丢失或被盗设备的数据。  </li>
<li>用户能够授权权限来限制对系统和用户数据的访问。  </li>
<li>应用程序定义的权限。]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.carrotsight.com/tags/Android/"/>
    
      <category term="安全" scheme="http://www.carrotsight.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="Android" scheme="http://www.carrotsight.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Think in Java》类型信息 – 学习笔记]]></title>
    <link href="http://www.carrotsight.com/2015/09/16/2015-9-16-%E3%80%8AThink-in-Java%E3%80%8B%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF-%E2%80%93-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://www.carrotsight.com/2015/09/16/2015-9-16-《Think-in-Java》类型信息-–-学习笔记.html</id>
    <published>2015-09-16T08:22:16.000Z</published>
    <updated>2015-12-03T08:07:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Class对象">Class对象</h2><p>Class对象是一种特殊的对象，它包含了与类有关的信息。Class对象用来创建类的所有的“常规”对象。Java使用Class对象来执行RTTI（包括类型转换操作）。<br>每当编写并编译一个新类，就会产生一个Class对象（或者说被保存在一个同名的.class文件中）。  </p>
<p>Class对象的引用可以通过Class.forName()或普通对象的getClass()方法来获取,或类名加上.class来获得。其中，getClass()方法属于根类Object的一部分。”.class”称为<em>类字面常量</em>，他在编译时就会受到检查，所以更安全，也更高效。  </p>
<p>差别：“.class”不会引起类的初始化，而Class.forName()方法会立即就进行初始化。<br><a id="more"></a><br>Class对象包含很多有用的方法，能够了解一个类型的所有信息，比如：  </p>
<ol>
<li>getName（）：产生全限定的类名  </li>
<li>getSimpleName（）：产生不含包名的类名  </li>
<li>getCanonicalName（）：产生全限定的类名  </li>
<li>isInterface（）：判定这个Class对象是否表示某个接口  </li>
<li>getSuperclass（）：查询直接基类```</li>
</ol>
<p>如果调用Class对象的newInstance（）方法来实例化一个类，则这个类必须带有默认构造器。  </p>
<p>为了使用类而做的准备工作实际包含3个步骤：  </p>
<ol>
<li><strong>加载</strong>。这是由类加载器执行的。该步骤查找字节码并从这些字节码中创建一个Class对象。  </li>
<li><strong>链接</strong>。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必要的话，将解析这个类创建的对其他类的所有引用。  </li>
<li><strong>初始化</strong>。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。  </li>
</ol>
<h2 id="反射：运行时的类信息">反射：运行时的类信息</h2><p>RTTI和反射之间真正的区别只在于，对RTTI来说，编译器在<strong>编译时</strong>打开和检查.class文件（即我们可以用“普通”方式调用对象的所有方法）。而对于反射机制来说，.class文件在编译时是不可获取的，所以是在<strong>运行时</strong>打开和检查.class文件。  </p>
<p>Class类与java.lang.reflect类库一起对<em>反射</em>的概念进行了支撑，该类库包含了Field、Method以及Constructor类（每个类都实现了Member接口）。这些类型的对象是由JVM在运行时创建的，用以表示未知类里对应的成员。这样就可以使用Constructor创建新的对象，用get()和set()方法读取和修改与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。另外，还可以调用getField()、getMethods()和getConstructors()等很便利的方法，以返回表示字段、方法以及构造器的对象的数组。这样，<strong>匿名对象的类信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。</strong>  </p>
<p>用如下代码来测试反射机制： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class&lt;?&gt; appleClass = Class.forName(<span class="string">"classinfo.Apple"</span>);</span><br><span class="line">			System.out.println(<span class="string">"===Methods:===\n"</span>);</span><br><span class="line">			<span class="keyword">for</span>( Method method : appleClass.getMethods())&#123;</span><br><span class="line">				System.out.println(method.toString());</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"===Constructors:===\n"</span>);</span><br><span class="line">			<span class="keyword">for</span>( Constructor&lt;?&gt; cons : appleClass.getConstructors())&#123;</span><br><span class="line">				System.out.println(cons.toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">	<span class="keyword">private</span> String color;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(<span class="keyword">int</span> weight, String color)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.weight = weight;</span><br><span class="line">		<span class="keyword">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">incWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ++weight;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> --weight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为： </p>
<blockquote>
<p>===Methods:===<br>public int classinfo.Apple.incWeight()<br>public int classinfo.Apple.decWeight()<br>public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException<br>public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException<br>public final void java.lang.Object.wait() throws java.lang.InterruptedException<br>public boolean java.lang.Object.equals(java.lang.Object)<br>public java.lang.String java.lang.Object.toString()<br>public native int java.lang.Object.hashCode()<br>public final native java.lang.Class java.lang.Object.getClass()<br>public final native void java.lang.Object.notify()<br>public final native void java.lang.Object.notifyAll()</p>
<p>===Constructors:===<br>public classinfo.Apple()<br>public classinfo.Apple(int,java.lang.String)</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Class对象">Class对象</h2><p>Class对象是一种特殊的对象，它包含了与类有关的信息。Class对象用来创建类的所有的“常规”对象。Java使用Class对象来执行RTTI（包括类型转换操作）。<br>每当编写并编译一个新类，就会产生一个Class对象（或者说被保存在一个同名的.class文件中）。  </p>
<p>Class对象的引用可以通过Class.forName()或普通对象的getClass()方法来获取,或类名加上.class来获得。其中，getClass()方法属于根类Object的一部分。”.class”称为<em>类字面常量</em>，他在编译时就会受到检查，所以更安全，也更高效。  </p>
<p>差别：“.class”不会引起类的初始化，而Class.forName()方法会立即就进行初始化。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://www.carrotsight.com/tags/Java/"/>
    
      <category term="reflection" scheme="http://www.carrotsight.com/tags/reflection/"/>
    
      <category term="反射" scheme="http://www.carrotsight.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="Java" scheme="http://www.carrotsight.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Otto学习笔记]]></title>
    <link href="http://www.carrotsight.com/2015/09/15/2015-9-15-Otto%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://www.carrotsight.com/2015/09/15/2015-9-15-Otto学习笔记.html</id>
    <published>2015-09-15T07:49:16.000Z</published>
    <updated>2015-12-02T04:19:44.000Z</updated>
    <content type="html"><![CDATA[<p>与EventBus类似的还有otto，于是也学习了一下。在网上找到的大部分博客其实都是对otto官方文档的中文翻译，对生产者的@Produce、PUBLISHING、PRODUCING之间的关系讲得比较模糊，也没有对EventBus的StickyEvnet与Otto中类似机制的对比，而这正是我想了解的。于是就自己写demo实验，以此文总结。</p>
<p><strong><br>本文的Otto指的是：square/otto<br>EventBus指的是：greenrobot/EventBus<br>Github上有很多同名项目，不要搞错。
</strong></p>
<p>本文档前面是对Otto各方面的介绍。如果要学习快速使用，可以直接跳转到后面的<a href="#详细使用实例">详细使用实例</a>部分。</p>
<h2 id="特点">特点</h2><p>Otto的作用与EventBus类似，都是用于组件间通信，降低不同的类相互之间的耦合。如果不熟悉EventBus，可以先了解EventBus，下文涉及到otto与EventBus的对比。</p>
<p>Otto可以随便定义订阅者的消息处理函数的函数名，采用注解的方式来识别生产函数和消费函数（@Produce和@Subscribe），这是与EventBus明显的不同。<br><a id="more"></a></p>
<h2 id="PUBLISHING、SUBSCRIBING与PRODUCING">PUBLISHING、SUBSCRIBING与PRODUCING</h2><p>虽然同样是订阅者模式的实现，但是Otto与Eventbus相比，多了一个“PRODUCING”的概念（Eventbus中只有PUBLISHING和SUBSCRIBING的概念）。<br>其实这里的PRODUCING设计的初衷与Eventbus中的StickyEvent是相似的，都是为了能够取到某中类型的事件的最新值，但在实现上有较大差异。</p>
<h3 id="订阅事件">订阅事件</h3><p><strong>用来消耗（或者说处理）事件的是订阅者，必须用@Subscribe标注。</strong>  订阅者（假定是一个Activity）需要在初始化时（onCreate()方法或onResume()方法中）使用register（）方法向总线注册，在onDestroy（）或onPause（）时调用unregister（）从总线反注册。  </p>
<h3 id="发布事件">发布事件</h3><h4 id="PUBLISHING">PUBLISHING</h4><p>而产生（或者说发布）事件的方式有两种，一种是不使用@Produce标注，这种方式被otto官方文档称为<strong>PUBLISHING</strong>，方法是直接调用bus对象的post方法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyApplicationUtil.bus.post(<span class="keyword">new</span> TextEvent(<span class="string">"这是PUBLISHING事件: "</span> + <span class="keyword">new</span> Date()));</span><br></pre></td></tr></table></figure>   </p>
<h4 id="PRODUCING">PRODUCING</h4><p>另一种是使用@Produce标注，这种方式被otto官方文档称为<strong>PRODUCING</strong>。如果使用了@Produce来标注生产者（即实现PRODUCING功能），就需要同时在初始化时使用bus.register(this)来注册这个生产者，在销毁组件时调用unregister（）。  </p>
<p>PRODUCING其实类似于EventBus中的StickyEvent。 用rigister方法注册@Produce标注的生产者（被注册的函数需要返回一个事件实例）时， @Produce标注的生产者函数会为所有之前注册了该事件类型的订阅者<strong>分别进行一次回调</strong>，并且此生产者函数也将为在此之后注册的该事件类型的订阅者<strong>分别进行一次回调</strong>。  </p>
<p>Otto没有EventBus中那种可以在任意地方获取StickyEvent的方法，因为虽然PRODUCING与StickyEvent类似，但<strong>Eventbus是通过一个map来缓存StickyEvent的最后一次更新值，不会触发任何函数回调，而Otto的PRODUCING并没有这种缓存，是实时去回调Produce函数来拿到最新值的</strong>。</p>
<p>PRODUCING的定义如下面代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Produce</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TextEvent <span class="title">postEvent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TextEvent(<span class="string">"hahaah"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里仅仅是为了实验调试是不是每个订阅者都触发这个回调，所以才写成每次return的都是new出来的新对象。事实上，Otto的文档中说@Produce机制是为了便于多个订阅者能全都某个事件的最新状态，比如最后一次定位的位置。所以，要实现官方文档中说的这一点，就不能在@Produce函数中每次return新对象，而是return一个外部的全局对象（event），这个对象在外围被其他逻辑更新，而不是不在@Produce函数中被更新。</p>
<p>在一个总线上（一个bus对象）上，同一时刻同一类型的用@Produce标注的事件生产者只能有一个。官方文档的原文是：</p>
<blockquote>
<p><strong>You may only have one producer per event type registered at a time on a bus.  </strong></p>
</blockquote>
<p>一般在使用EventBus时，会直接采用EventBus.getDefault()来获取系统默认提供的单例对象，然后再该对象（总线对象）上进行实践的发布和订阅。但是otto没有提供默认的单例，一般需要自己在应用程序范围内，自己去手动创建并维护一个otto的bus对象。</p>
<p>Otto在初始化Bus的时候来决定处理事件的执行线程。默认只有ThreadEnforcer.ANY和ThreadEnforcer.MAIN两种。如果需要其他类型的线程控制，需要自己实现ThreadEnforcer接口。相对而言，EventBus的控制更精细更简单。   </p>
<h2 id="与EventBus的对比">与EventBus的对比</h2><p><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-8-28/24002070.jpg" alt="Otto与EventBus的对比"></p>
<h2 id="详细使用实例"><a href="id:详细使用实例" target="_blank" rel="external">详细使用实例</a></h2><p>1.在build.gradle的dependencies中加入以下内容：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.squareup:otto:1.3.8'</span></span><br></pre></td></tr></table></figure>
<p>2.根据业务需要定义事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextEvent</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.创建一个类，在整个应用程序范围内持有一个总线对象。（使用EventBus不需要这一步，因为EventBus已近替我们实现好了默认的单例对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bus bus = <span class="keyword">new</span> Bus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.在需要订阅事件的组件中（即订阅者，假设是一个Activity），做以下三个工作：  </p>
<ul>
<li>在初始化组件时向总线注册自己为某类型事件的订阅者  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main3);</span><br><span class="line">       tv = (TextView)findViewById(R.id.getdatatv);</span><br><span class="line">       </span><br><span class="line">       MyApplicationUtil.bus.register(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现事件处理函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Subscribe</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEvent</span><span class="params">(TextEvent event)</span></span>&#123;</span><br><span class="line">       tv.setText(event.getData());</span><br><span class="line">       Log.d(<span class="string">"TAG"</span>,  <span class="string">"==in Main3Activity==   getEvent:"</span> + event.getData());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在组件销毁时反注册订阅者</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onDestroy();</span><br><span class="line">       MyApplicationUtil.bus.unregister(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>5.在产生事件的组件（生产者）中，如果只是发送普通事件，就直接调用bus对象的post方法即可，之前注册的订阅者就可以接收到这个事件了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyApplicationUtil.bus.post(<span class="keyword">new</span> TextEvent(dataEditText.getText().toString()));</span><br></pre></td></tr></table></figure>
<p>6.如果需要实现PRODUCING功能（即类似StickyEvent功能），就需要用@Producer显示标注生产者，同时也要对该生产者进行注册和反注册，如下面代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main2);</span><br><span class="line">       dataEditText = (EditText)findViewById(R.id.activity2_et);</span><br><span class="line">       btn1 = (Button)findViewById(R.id.activity2_btn1);</span><br><span class="line">       btn1.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       MyApplicationUtil.bus.register(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="annotation">@Produce</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TextEvent <span class="title">postEvent</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> TextEvent(<span class="string">"hahaah"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onDestroy();</span><br><span class="line">       MyApplicationUtil.bus.unregister(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>按照这种方式显示定义了生产者之后，之前在此bus上注册过的所有该类型事件的订阅者都会接收到本事件的实例。之后再再此bus上注册的此类型的新的订阅者同样能够接收到本事件实例。</p>
<hr>
<p>参考资料</p>
<ol>
<li><p><a href="https://github.com/square/otto" target="_blank" rel="external">官方下载：https://github.com/square/otto</a></p>
</li>
<li><p><a href="http://square.github.io/otto/" target="_blank" rel="external">官方使用说明：http://square.github.io/otto/</a></p>
</li>
<li><p><a href="http://blog.csdn.net/wangjia55/article/details/17148535" target="_blank" rel="external">Otto介绍：http://blog.csdn.net/wangjia55/article/details/17148535</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/qianxudetianxia/p/4216949.html" target="_blank" rel="external">使用事件总线框架EventBus和Otto：<br>http://www.cnblogs.com/qianxudetianxia/p/4216949.html</a></p>
</li>
<li><p><a href="http://m.blog.csdn.net/blog/Estellise/41758401" target="_blank" rel="external">Android组件间通信机解耦——Android EventBus和Otto框架：<br>http://m.blog.csdn.net/blog/Estellise/41758401</a></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>与EventBus类似的还有otto，于是也学习了一下。在网上找到的大部分博客其实都是对otto官方文档的中文翻译，对生产者的@Produce、PUBLISHING、PRODUCING之间的关系讲得比较模糊，也没有对EventBus的StickyEvnet与Otto中类似机制的对比，而这正是我想了解的。于是就自己写demo实验，以此文总结。</p>
<p><strong><br>本文的Otto指的是：square/otto<br>EventBus指的是：greenrobot/EventBus<br>Github上有很多同名项目，不要搞错。
</strong></p>
<p>本文档前面是对Otto各方面的介绍。如果要学习快速使用，可以直接跳转到后面的<a href="#详细使用实例">详细使用实例</a>部分。</p>
<h2 id="特点">特点</h2><p>Otto的作用与EventBus类似，都是用于组件间通信，降低不同的类相互之间的耦合。如果不熟悉EventBus，可以先了解EventBus，下文涉及到otto与EventBus的对比。</p>
<p>Otto可以随便定义订阅者的消息处理函数的函数名，采用注解的方式来识别生产函数和消费函数（@Produce和@Subscribe），这是与EventBus明显的不同。<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.carrotsight.com/tags/Android/"/>
    
      <category term="EventBus" scheme="http://www.carrotsight.com/tags/EventBus/"/>
    
      <category term="Otto" scheme="http://www.carrotsight.com/tags/Otto/"/>
    
      <category term="观察者模式" scheme="http://www.carrotsight.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Android" scheme="http://www.carrotsight.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[EventBus学习总结]]></title>
    <link href="http://www.carrotsight.com/2015/09/14/2015-9-14-EventBus%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html"/>
    <id>http://www.carrotsight.com/2015/09/14/2015-9-14-EventBus学习总结.html</id>
    <published>2015-09-14T12:12:43.000Z</published>
    <updated>2015-12-02T13:07:27.000Z</updated>
    <content type="html"><![CDATA[<p>这两天对Github上很火的Eventbus进行了学习，查阅了一些博客，写代码做了实验，以此文总结。<br>本文档前面是对EventBus各方面的介绍。如果要学习快速使用，可以直接跳转到后面的<a href="#详细使用实例">详细使用实例</a>部分。</p>
<p><strong>本文EventBus指的是：greenrobot/EventBus<br>Github上有很多同名项目，不要搞错。</strong><br>EventBus是使用观察者模式来替代Intent、Handler、Broadcast的在Activity、Fragment、Service之间传递消息的机制。能降低组件间的耦合，使代码更简洁。</p>
<h2 id="概念图">概念图</h2><p><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-8-28/38822932.jpg" alt="EventBus概念图"><br><a id="more"></a></p>
<h2 id="特点">特点</h2><p>“事件”是一个POJO，根据自己需要自己随便定义的一个JAVA类，包含需要传递给其他组件的信息。  </p>
<p>事件发布者不需要注册，直接使用EventBus.getDefault().post(new TextEvent(“我有一头小毛驴”))。其中TextEvent是一个自定义类。  </p>
<p>事件订阅者（接受者、处理者）需要在onCreate()方法中通过EventBus.getDefault().register(this)注册自己，在onDestroy()方法中通过EventBus.getDefault().unregister(this)取消注册。同时，需要至少实现4种onEventXXX方法中的一种。   </p>
<p>支持4种事件响应模式：  </p>
<blockquote>
<ol>
<li>MainThread：对应的响应函数写法为onEventMainThread，事件响应函数会在Android应用的主线程(大部分情况下都是UI线程)中执行。</li>
<li>PostThread：对应的响应函数写法为onEvent，即默认的处理方式就是post方式。事件响应函数和事件发布在同一线程中执行。这个是默认值，这样可以避免线程切换。</li>
<li>BackgroundThread：对应的响应函数写法为onEventBackgroundThread，事件响应函数会在一个后台线程中执行。如果事件发布函数不是在主线程中，则会立即在事件发布线程中执行响应函数。如果事件发布函数在主线程中，EventBus则会在唯一的一个后台线程中按照顺序来执行所有的后台事件响应函数。</li>
<li>Async：对应的响应函数写法为onEventAsync，每接收到一个事件都会开启一个异步线程执行。  </li>
</ol>
</blockquote>
<p>前3种响应函数都要求其中不能有耗时操作，防止UI更新、事件分发或新事件的处理等操作被阻塞。 </p>
<p>通过实验，如果在同一个订阅者中对同一个事件同时注册了这4种响应函数，则控制台打印的时间处理函数顺序为 :</p>
<blockquote>
<p>onEvent()-&gt;onEventMainThread()-&gt;onEventAsync()-&gt;onEventBackgroundThread()</p>
</blockquote>
<p>或</p>
<blockquote>
<p>onEvent()-&gt;onEventMainThread()-&gt;onEventBackgroundThread()-&gt;onEventAsync()。 </p>
</blockquote>
<p>由于onEventBackgroundThread（）和onEventAsync（）都是在后台线程执行的，包括在控制台打印函数名的操作，所以此顺序不一定就是这几个函数被触发的顺序。</p>
<h2 id="优先级">优先级</h2><p>EventBus在注册订阅者时需要指定此订阅者的优先级，用整型数表示，数字越大优先级越高。如果不显示指定优先级，则默认为0。优先级可以为负数。  </p>
<p>对于同一个事件的多个订阅者，高优先级的订阅者会先接收到Event。</p>
<p>接收到Event的订阅者可以决定是否取消事件的传递，来使后面的订阅者无法接收到Event。方法是在onEvent方法中调用EventBus.getDefault().cancelEventDelivery(event)，也就是说，只能在Post线程的onEvent方法中取消事件的传递。 </p>
<p>经过实验，<strong>相同优先级的订阅者是按照注册的先后顺序来接收事件的</strong>。先接收到事件的订阅者如果在onEvent()方法中调用EventBus.getDefault().cancelEventDelivery(event)，同样可以中断事件继续传播，但中断得不彻底，紧随其后的1个订阅者仍然有可能接收到事件。</p>
<p><strong><em>注意：</em></strong>  </p>
<p>如果第一个接收到时间的订阅者在任何一个订阅函数中对接收到的event的内容做了修改，那么后续的其他订阅者的所有onEventXXX函数接受到的event也都是被修改的。即<strong>post操作只产生一个event对象，所有订阅者的onEventXXX函数接受到的都是同一个对象的引用</strong>。</p>
<p>如果event被生产者post之后，订阅者接收到了事件并足够快的对该event的某些字段做了修改，那么生产者在post语句之后对event的引用也会体现出字段的修改。这里的“足够快”没有定论，实验的每次结果都有差异，不过基本的规律是生产者的post（）语句之后的下一条语句，会在所有订阅者的onEvent()和onEventMainThread()都执行完成后才执行。而onEventAsync()和onEventBackgroundThread()相对于post（）下一条语句的执行顺序则没有定论。</p>
<h2 id="关于cancelEventDelivery的问题">关于cancelEventDelivery的问题</h2><p>如果在post线程的onEvent方法中，先有一段特别耗时的操作，然后才调用cancelEventDelivery，那么后面的订阅者有可能因为cancelEventDelivery没被即时执行而接收到事件吗？比如订阅者1的onEvent方法是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(TextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">99999999</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = i;</span><br><span class="line">            &#125;</span><br><span class="line">            EventBus.getDefault().cancelEventDelivery(event);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么本该在订阅者1后面才接收到事件的订阅者2会接收到event吗？也许EventBus会在for循环这段时间内已近把事件传递给订阅者2了，毕竟这时还没有执行EventBus.getDefault().cancelEventDelivery(event)？</p>
<p>带着这个问题，跟进了一下EventBus的源码，有以下发现。  </p>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-2/91530689.jpg" alt=""></p>
<p>在事件生产者调用post方法时，Eventbus内部是通过调用这个postSingleEventForEventType<br>方法来进行消息传递的，一旦EventBus.getDefault().cancelEventDelivery<br>(event)方法被调用，aborted就被置为false，这个for循环就会停止，消息不会再向后面任何订阅者的任何一种线程函数传递。<br>由于cancelEventDelivery方法只能在post线程的onEvent函数中调用，而这里的postToSubscription方法对于post线程的执行是同步的，所以即使某个订阅者在post线程的onEvent中先进行耗时操作再调用cancelEventDelivery，后面的订阅者也接受不到这个事件，因为postSingleEventForEventType方法还在等待2返回（同步方法）。  </p>
<p>postToSubscription的内部实现如下：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-2/70984573.jpg" alt=""></p>
<p>我用代码在各种线程中都试过了，确实不用担心cancelEventDelivery之前的耗时操作导致在耗时操作期间事件仍然被传递的问题。只有一种例外，就是在post线程的onThread方法中再启新线程进行cancelEventDelivery调用，不会这样做没有意义，因为eventbus已经提供了4种线程模型了，不需要这样多此一举， 相信不会有人这样写代码，就像下面这样：<br><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-12-2/40991601.jpg" alt=""></p>
<h2 id="基本用法流程3步搞定">基本用法流程3步搞定</h2><p>1.定义事件  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123; <span class="comment">/* Additional fields if needed */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>2.注册订阅者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.register(<span class="keyword">this</span>);<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(AnyEventType event)</span> </span>&#123;<span class="comment">/* Do something */</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>3.发送事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.post(event);</span><br></pre></td></tr></table></figure>
<h2 id="StickyEvent">StickyEvent</h2><p>除了普通的Event，还有一类特殊的StickyEvent，它也是POJO，事件本身和普通事件无区别，只是在注册订阅者注册时需要使用EventBus.getDefault().registerSticky(this)。事件处理函数的函数名也与普通事件的处理函数一样，因为注册为了StickyEvent的监听器，所以EventBus在调用这些事件处理函数时会按照StickyEvent的方式来处理。  </p>
<p>StickyEvent与普通Event的普通就在于，EventBus会自动维护被作为StickyEvent被post出来（即在发布事件时使用EventBus.getDefault().postSticky(new MyEvent())方法）的事件的最后一个副本在缓存中。  </p>
<p>任何时候在任何一个订阅了该事件的订阅者中的任何地方（可以在任何函数中，而不仅仅是在onEventXXX方法中），都可以通过EventBus.getDefault().getStickyEvent(MyEvent.class)来取得该类型事件的最后一次缓存。  </p>
<p>同时，即便事件已经在所有订阅者中传递完成了，如果此时再创建一个新的订阅者（如一个注册了该StickyEvent的Activity），则在订阅者启动后，会自动调用一次该订阅者的noEventXXX方法来处理该StickyEvent。  </p>
<p>也可以在需要的时候，利用removeStickyEvent方法来移除对某种StickyEvent的缓存。</p>
<h2 id="网上博文总结EventBus的优点">网上博文总结EventBus的优点</h2><blockquote>
<ol>
<li>支持在不同类型的线程中处理订阅，包括发布所在线程，UI线程、单一后台线程、异步线程</li>
<li>支持事件优先级定义，支持优先级高的订阅者取消事件继续传递，支持粘性事件，是不是跟系统的有序广播、粘性广播很像啊</li>
<li>不是基于annotations</li>
<li>性能更优</li>
<li>体积小</li>
<li>支持单例创建或创建多个对象</li>
<li>支持根据事件类型订阅</li>
</ol>
</blockquote>
<h2 id="详细使用实例"><a href="id:详细使用实例" target="_blank" rel="external">详细使用实例</a></h2><p>1.准备工作：  </p>
<p>在项目build.gradle的dependencies中加入以下内容：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'de.greenrobot:eventbus:2.4.0'</span></span><br></pre></td></tr></table></figure></p>
<p>2.编写事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextEvent</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    	<span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.在需要订阅该事件的Activity的onCreate（）方法中，把自己注册为订阅者。<br>默认使用EventBus提供的默认总线，即EventBus.getDefault()方法获得的总线，其内部实现了单例模式。自己也可以根据需要定制不同的总线。<br>register()方法是向总线订阅普通事件，registerSticky方法是向总线订阅Sticky事件。只能使用二者当中的一种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    	<span class="comment">//EventBus.getDefault().registerSticky(this);</span></span><br><span class="line">        EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.在注册为订阅者的Activity的onDestroy（）方法中，解除注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">	<span class="keyword">super</span>.onDestroy();</span><br><span class="line">	EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.在注册为订阅者的Activity中，编写事件处理方法。<br>下面的代码列举了4种线程类型的事件处理方法，实际使用时可以根据需要只实现其中的几种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventAsync</span><span class="params">(TextEvent event)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">/* messageTextView.setText(event.getMsg());</span><br><span class="line">           Toast.makeText(this, event.getMsg(), Toast.LENGTH_SHORT).show();*/</span></span><br><span class="line">           Log.d(<span class="string">"TAG"</span>, event.getMsg());</span><br><span class="line">           Log.d(<span class="string">"onEvent"</span>, <span class="string">"onEventAsync()"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(TextEvent event)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           messageTextView.setText(event.getMsg());</span><br><span class="line">           Toast.makeText(<span class="keyword">this</span>, event.getMsg(), Toast.LENGTH_SHORT).show();</span><br><span class="line">           Log.d(<span class="string">"TAG"</span>, event.getMsg());</span><br><span class="line">           Log.d(<span class="string">"onEvent"</span>, <span class="string">"onEvent()"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMainThread</span><span class="params">(TextEvent event)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">/* messageTextView.setText(event.getMsg());</span><br><span class="line">           Toast.makeText(this, event.getMsg(), Toast.LENGTH_SHORT).show();*/</span></span><br><span class="line">           Log.d(<span class="string">"TAG"</span>, event.getMsg());</span><br><span class="line">           Log.d(<span class="string">"onEvent"</span>, <span class="string">"onEventMainThread()"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventBackgroundThread</span><span class="params">(TextEvent event)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">/* messageTextView.setText(event.getMsg());</span><br><span class="line">           Toast.makeText(this, event.getMsg(), Toast.LENGTH_SHORT).show();*/</span></span><br><span class="line">           Log.d(<span class="string">"TAG"</span>, event.getMsg());</span><br><span class="line">           Log.d(<span class="string">"onEvent"</span>, <span class="string">"onEventBackgroundThread()"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>6.在需要产生事件的组件（Activity、Fragment、Service等）中，调用发送事件的方法。<br>下面的代码列举了发送普通事件和发送Sticky事件两种情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (v.getId())&#123;</span><br><span class="line">           <span class="keyword">case</span> R.id.activity8_btn1:</span><br><span class="line">               EventBus.getDefault().post(<span class="keyword">new</span> TextEvent(<span class="string">"我有一头小毛驴"</span>));</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">case</span> R.id.activity8_btn2:</span><br><span class="line">               EventBus.getDefault().postSticky(<span class="keyword">new</span> TextEvent(<span class="string">"我有一头小毛驴"</span>));</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这样，当点击按钮触发onClick（）时，就能在第5步的MainActivity中的onEventXXX方法中接收到事件了。<br>如果发送的是Sticky事件，则可以在任何需要获取该事件的地方通过EventBus.getDefault().getStickyEvent(TextEvent.class)方法来获取该类型的StickyEvent的最后一次数据。</p>
<hr>
<p>参考资料</p>
<ol>
<li><p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">官方下载: https://github.com/greenrobot/EventBus
</a></p>
</li>
<li><p><a href="https://github.com/greenrobot/EventBus/blob/master/HOWTO.md" target="_blank" rel="external">官方使用说明: https://github.com/greenrobot/EventBus/blob/master/HOWTO.md</a></p>
</li>
<li><p><a href="http://blog.csdn.net/marktheone/article/details/47725553" target="_blank" rel="external">EventBus, otto, LocalBroadcast的对比：http://blog.csdn.net/marktheone/article/details/47725553</a></p>
</li>
<li><p><a href="http://blog.csdn.net/harvic880925/article/details/40660137" target="_blank" rel="external">EventBus使用详解：<br>http://blog.csdn.net/harvic880925/article/details/40660137</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/wangjq/archive/2012/07/12/2587966.html" target="_blank" rel="external">观察者模式：<br>http://www.cnblogs.com/wangjq/archive/2012/07/12/2587966.html</a></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两天对Github上很火的Eventbus进行了学习，查阅了一些博客，写代码做了实验，以此文总结。<br>本文档前面是对EventBus各方面的介绍。如果要学习快速使用，可以直接跳转到后面的<a href="#详细使用实例">详细使用实例</a>部分。</p>
<p><strong>本文EventBus指的是：greenrobot/EventBus<br>Github上有很多同名项目，不要搞错。</strong><br>EventBus是使用观察者模式来替代Intent、Handler、Broadcast的在Activity、Fragment、Service之间传递消息的机制。能降低组件间的耦合，使代码更简洁。</p>
<h2 id="概念图">概念图</h2><p><img src="http://7xle8x.com1.z0.glb.clouddn.com/15-8-28/38822932.jpg" alt="EventBus概念图"><br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.carrotsight.com/tags/Android/"/>
    
      <category term="EventBus" scheme="http://www.carrotsight.com/tags/EventBus/"/>
    
      <category term="Android" scheme="http://www.carrotsight.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Think in Java》并发 - 学习笔记]]></title>
    <link href="http://www.carrotsight.com/2015/09/08/2015-9-8-%E3%80%8AThink-in-Java%E3%80%8B%E5%B9%B6%E5%8F%91-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
    <id>http://www.carrotsight.com/2015/09/08/2015-9-8-《Think-in-Java》并发-学习笔记.html</id>
    <published>2015-09-08T08:08:15.000Z</published>
    <updated>2015-12-03T08:07:13.000Z</updated>
    <content type="html"><![CDATA[<p>1.Executor允许你管理异步任务的执行，而无须显示地管理线程的生命周期。Executor在Java SE5/6中是启动任务的优选方法。可以使用Executor来代替显示地创建Thread对象。  </p>
<p>2.ExecutorService知道如何构建恰当的上下文来执行Runnable对象。  </p>
<p>3.CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后再它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。只有当这种方式会引发问题时，才需要切换到FixedThreadPool。<br><a id="more"></a><br>4.SingleThreadExecutor就像是线程数量为1的FixedThreadPool。如果向SingleThreadExecutor提交了多个任务，那么这些任务将排队，每个任务都会在下一个任务开始之前运行结束，所有的任务将使用相同的线程。SingleThreadExecutor会序列化所有提交给它的任务，并会维护它自己（隐藏）的悬挂任务队列。<br>SingleThreadExecutor确保任何时刻在任何线程中都只有唯一的任务在运行，就不需要在共享资源上处理同步。  </p>
<p>5.Runnable是执行工作的独立任务，但是他不返回任何值。如果希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口。在Java SE5中引入的Callable是一种具有类型参数的泛型，它的类型参数表示的是从方法call（）（而不是run（））中返回的值，并且必须使用ExecutorService.submit（）方法调用它。<br>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread.sleep((<span class="keyword">new</span> Random()).nextInt(<span class="number">2000</span>) + <span class="number">1000</span>);<span class="comment">//在这里随机睡眠时间，为了测试Future.isDone()的效果</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"TaskWithResult id: "</span> + id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">		ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			results.add(exec.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(Future&lt;String&gt; fs : results)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"\n==taskIndex "</span> + results.indexOf(fs) + <span class="string">"=="</span>);</span><br><span class="line">				System.out.println(<span class="string">"isDone(): "</span> + fs.isDone());</span><br><span class="line">				System.out.println(fs.get());</span><br><span class="line">				System.out.println(<span class="string">"isDone(): "</span> + fs.isDone());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">				exec.shutdown();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<blockquote>
<p>==taskIndex 0==<br>isDone(): false<br>TaskWithResult id: 0<br>isDone(): true</p>
<p>==taskIndex 1==<br>isDone(): false<br>TaskWithResult id: 1<br>isDone(): true</p>
<p>==taskIndex 2==<br>isDone(): true<br>TaskWithResult id: 2<br>isDone(): true</p>
<p>==taskIndex 3==<br>isDone(): false<br>TaskWithResult id: 3<br>isDone(): true</p>
<p>==taskIndex 4==<br>isDone(): true<br>TaskWithResult id: 4<br>isDone(): true</p>
<p>==taskIndex 5==<br>isDone(): true<br>TaskWithResult id: 5<br>isDone(): true</p>
<p>==taskIndex 6==<br>isDone(): true<br>TaskWithResult id: 6<br>isDone(): true</p>
<p>==taskIndex 7==<br>isDone(): false<br>TaskWithResult id: 7<br>isDone(): true</p>
<p>==taskIndex 8==<br>isDone(): true<br>TaskWithResult id: 8<br>isDone(): true</p>
<p>==taskIndex 9==<br>isDone(): true<br>TaskWithResult id: 9<br>isDone(): true</p>
</blockquote>
<p>且每当输出到isDone(): false的地方，输出线程就会卡住，直到取到这个线程的返回值后，才会继续后续的打印。  </p>
<p>Future的javadoc说明如下：  </p>
<blockquote>
<p>A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the cancel method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future&lt;?&gt; and return null as a result of the underlying task.</p>
</blockquote>
<p>Future.get()方法的javadoc说明如下：  </p>
<blockquote>
<p>Waits if necessary for the computation to complete, and then retrieves its result.</p>
</blockquote>
<p>6.调度器倾向于让优先级最高的线程先执行。如果要设置线程的优先级，应该在run（）方法体中使用<br><code>Thread.currentThread().setPriority(newPriority)</code>来设置，而不要在构造器中设置。<br>不同操作系统对优先级的分级不同，为了可移植性，应该只使用MAX_PRIORITY、NORM_PRIORITY和MIN_PRIORITY三种级别。  </p>
<p>7.yield（）方法会暗示线程调度器，我的工作做得差不多了，具有相同优先级的其他线程可以运行了。但这仅仅是一个暗示，没有任何机制保证它将被采纳。所以，不能依赖于yield（）。实际上，yield（）经常被误用。  </p>
<p>8.所谓后台（daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，<strong>当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程</strong>。反过来说，只要有任何非后台线程还在运行，程序就不会终止。<br>必须在线程启动之前调用setDaemon（）方法才能把它设置为后台线程，如以下代码： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread daemon = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SimpleDaemon());</span><br><span class="line">daemon.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">daemon.start();</span><br></pre></td></tr></table></figure>
<p>可以用isDaemon()方法来确定线程是否是一个后台线程。如果是一个后台线程，那么它创建的任何子线程都将被自动设置成后台线程。</p>
<p>9.是线程睡眠时可以调用  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.MILLISECONDS.sleep(timeout);</span><br><span class="line">TimeUnit.HOURS.sleep(timeout);</span><br><span class="line">TimeUnit.MICROSECONDS.sleep(timeout);</span><br></pre></td></tr></table></figure>
<p>等方法来代替直接调用<code>Thread.sleep(timeout)</code>方法，这样时间的长度就更直观，这些方法内部会自动调用Thread.sleep(timeout)方法。  </p>
<p>10.join()方法：  </p>
<ul>
<li>一个线程可以在其他线程之上调用join（）方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程t上调用t.join()，此线程将被挂起，直到目标线程t结束才恢复（即t.isAlive()返回为假）。  </li>
<li>可以在调用join()时带上一个超时参数（单位可以是毫秒，或者毫秒和纳秒），这样如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回。</li>
<li>对join()方法的调用可以被中断，做法是在调用join（）的线程上再次调用interrupt()方法。  </li>
</ul>
<p>11.由于线程的本质特性，不能捕获从线程中逃逸的异常，即使在主线程中执行子线程任务时把它包在try-catch块中，任然无法捕获到逃逸的异常，异常会直接向外传播的控制台。为了捕获异常，可以在每个新创建的Thread对象上附着一个Thread.UncaughtExceptionHandler。</p>
<p>例如下面的代码：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"I throw this Exception on purpose!"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExceptionCaughtTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">			t1.start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.out.println(<span class="string">"Haha! Exception caught!!!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行的结果为：  </p>
<blockquote>
<p>Exception in thread “Thread-0” java.lang.RuntimeException: I throw this Exception on purpose!<br>    at MyThread.run(ThreadExceptionCaughtTest.java:5)</p>
</blockquote>
<p>可见try-catch并不能捕获到我在MyThread中抛出的异常。  </p>
<p>那么我为MyThread附加一个我自己实现的UncaughtExceptionHandler，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"I throw this Exception on purpose!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Haha! I caught : "</span> + e);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExceptionCaughtTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">			t1.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">			t1.start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			System.out.println(<span class="string">"Haha! Exception caught!!!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
<p>执行的结果为：</p>
<blockquote>
<p>Haha! I caught : java.lang.RuntimeException: I throw this Exception on purpose!</p>
</blockquote>
<p>可以看到MyUncaughtExceptionHandler成功捕获到了MyThread抛出的异常，try-catch仍然没有捕获到异常。  </p>
<p>12.关于<strong>synchronized方法</strong><br>所有对象都自动含有单一的锁（也称为监视器）。当在对象上调用其任意synchronized方法的时候，此对象都被加锁，<strong>这时该对象上的其他synchronized方法只有等到前一个方法调用完毕并释放了锁之后才能被调用</strong>。<br>例如这段代码：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAccount</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> account;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserAccount</span><span class="params">(<span class="keyword">int</span> account)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.account = account;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">			System.out.println(<span class="string">"incAccount result: "</span> + ++account);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"decAccount result: "</span> + --account);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		UserAccount ua = <span class="keyword">new</span> UserAccount(<span class="number">200</span>);</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				ua.incAccount();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				ua.decAccount();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(<span class="string">"===start==="</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
<p>其执行结果始终为：  </p>
<blockquote>
<p>===start===<br>incAccount result: 201<br>decAccount result: 200</p>
</blockquote>
<p>且控制台打印出“===start===”后，会暂停2秒钟才继续输出后面的2行结果。</p>
<p>而如果把函数decAccount（）前面的synchronized修饰符去掉，则打印结果为：   </p>
<blockquote>
<p>===start===<br>decAccount result: 199<br>incAccount result: 200</p>
</blockquote>
<p>且前两行结果是瞬间打印出来的，然后暂停了2秒，才输出最后一行结果。  </p>
<p>13.在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就不能防止其他任务直接访问域，这样就会产生冲突。<br>如果你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关的方法。</p>
<p>14.一个任务可以多次获得对象的锁。JVM负责跟踪对象被加锁的次数。只有首先获得了锁的任务才能允许继续获取多个锁。  </p>
<p>15.针对每个类，也有一个锁，作为类的Class对象的一部分，所以synchronized static方法可以在类的范围内防止对static数据的并发访问。  </p>
<p>16.在java.util.concurrent.locks中定义了显示的互斥机制Lock。Lock对象必须被显示地创建、锁定和释放。<br>好的使用习惯是，使用try-finally语句块，将lock（）放在try中，将unlock（）放在finally中。注意，return语句必须放在try子句中，以确保unlock（）不会过早发生，从而将数据暴露给第二个任务。  </p>
<p>17.如果将一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改。即便使用了本地缓存，情况也确实如此，volatile域会立即被写入到主存中，而读取操作就发生在主存中。<br>如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则，这个域就应该只能经由同步来访问。同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护，那就不必将其设置为是volatile的。<br>使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域。你的第一选择应该是使用synchronized关键字，这是最安全的方式，而尝试其他任何方式都是有风险的。（我理解这句话想表达的意思是，尽量不要使用volatile关键字，而是使用synchronized关键字或者Lock类。）  </p>
<p>18.调用sleep()和yield（）的时候并没有释放锁。<br>调用wait()的时候锁被释放。<br>wait()、notify（）以及notifyAll()有一个比较特殊的方面，那就是这些方法是基类Object的一部分，而不是属于Thread的一部分，只能在synchronized方法或synchronized块中调用这几个方法。sleep（）可以在非synchronized控制方法里调用，是因为不用操作锁。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1.Executor允许你管理异步任务的执行，而无须显示地管理线程的生命周期。Executor在Java SE5/6中是启动任务的优选方法。可以使用Executor来代替显示地创建Thread对象。  </p>
<p>2.ExecutorService知道如何构建恰当的上下文来执行Runnable对象。  </p>
<p>3.CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后再它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。只有当这种方式会引发问题时，才需要切换到FixedThreadPool。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://www.carrotsight.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.carrotsight.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://www.carrotsight.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java" scheme="http://www.carrotsight.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【FLEX bug:无法启动服务，因为fml文件损坏】的解决办法]]></title>
    <link href="http://www.carrotsight.com/2013/12/02/2013-12-2-FLEX%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%9B%A0%E4%B8%BAfml%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F.html"/>
    <id>http://www.carrotsight.com/2013/12/02/2013-12-2-FLEX无法启动服务因为fml文件损坏.html</id>
    <published>2013-12-02T05:01:15.000Z</published>
    <updated>2015-12-03T12:00:06.000Z</updated>
    <content type="html"><![CDATA[<p>在Flash Builder中，提示</p>
<blockquote>
<p>FLEX bug:无法启动服务，因为fml文件损坏。</p>
</blockquote>
<a id="more"></a>
<p>具体错误提示忘了，差不多就是这句话。</p>
<p>如果遇到这种情况，把项目目录下的.model/<em>*</em>.fml文件用文本编辑器打开，删掉坏掉的服务，也就是<service>标签之间的部分，然后在回去看FLEX，就可以删掉之前的数据服务了。</service></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Flash Builder中，提示</p>
<blockquote>
<p>FLEX bug:无法启动服务，因为fml文件损坏。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Flex" scheme="http://www.carrotsight.com/categories/Flex/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Flex中datagrid中checkbox的全选实现]]></title>
    <link href="http://www.carrotsight.com/2013/04/03/2013-4-3-Flex%E4%B8%ADdatagrid%E4%B8%ADcheckbox%E7%9A%84%E5%85%A8%E9%80%89%E5%AE%9E%E7%8E%B0.html"/>
    <id>http://www.carrotsight.com/2013/04/03/2013-4-3-Flex中datagrid中checkbox的全选实现.html</id>
    <published>2013-04-03T03:44:21.000Z</published>
    <updated>2015-12-03T08:05:31.000Z</updated>
    <content type="html"><![CDATA[<p>假设住程序的表格中有一列是checkbox，用户勾选后进行其他操作，定义为：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">chkChooseAll_changeHandler</span><span class="params">(event:Event)</span><span class="type">:void</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> <span class="keyword">each</span>(<span class="keyword">var</span> item:XML <span class="keyword">in</span> adg.dataProvider)</span><br><span class="line">   &#123;</span><br><span class="line">       item.@selected = chkChooseAll.selected;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>即将表格数据源对应项的selectd属性设置为全选框的选中状态。</p>
<p>下面主要要处理表格中chkCol列对属性改变的响应，即自动更新全选状态。方法为：<br>在itemRender中，重载data属性的set方法，如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> <span class="title">data</span><span class="params">(value:Object)</span><span class="type">:void</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value.@selected == <span class="string">"true"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         chkbox.selected = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         chkbox.selected = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的itemRender源码如下图：</p>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/FlexItemRender.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设住程序的表格中有一列是checkbox，用户勾选后进行其他操作，定义为：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">chkChooseAll_changeHandler</span><span class="params">(event:Event)</span><span class="type">:void</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> <span class="keyword">each</span>(<span class="keyword">var</span> item:XML <span class="keyword">in</span> adg.dataProvider)</span><br><span class="line">   &#123;</span><br><span class="line">       item.@selected = chkChooseAll.selected;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Flex" scheme="http://www.carrotsight.com/categories/Flex/"/>
    
  </entry>
  
</feed>
