<h1 align="center" class="root"><br><a name="3havsr3p3t101hrdlbi9m7usv6">学习笔记：Android中的View</a><br></h1>

<p><a href="http://www.carrotsight.com">返回本站首页</a></p>
<p>“Android中的View” 知识点学习梳理，包括了View事件的处理、View绘制3大流程等内容。</p>
<p>用XMind画的思维导图，导出为HTML格式了，点开页面可以查看清晰的图片，以及各部分的导出文字。  </p>
<p><a href="http://7xle8x.com1.z0.glb.clouddn.com/16-4-1/43527743-Android中的View.xmind" target="_blank" rel="external">点击这里下载 View知识点 XMind原始文件</a></p>
<a id="more"></a>
<p>因为图片太大，如果渲染为与本站一致的主题会导致图片看不清，所以本页面未进行样式渲染，比较丑，凑合着看吧。😊</p>
<p><img src="http://7xle8x.com1.z0.glb.clouddn.com/16-4-1/742250.jpg" alt=""></p>
<html><br><head><br><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><br><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><br><meta content="text/css" http-equiv="Content-Style-Type"><br><title>Android中的View</title><br><br><script><br>var _hmt = _hmt || [];<br>(function() {<br>  var hm = document.createElement(“script”);<br>  hm.src = “//hm.baidu.com/hm.js?449259d6f926d9e469b862f243275e59”;<br>  var s = document.getElementsByTagName(“script”)[0];<br>  s.parentNode.insertBefore(hm, s);<br>})();<br></script><br><br><br></head><br><body><br><h2 class="topic"><br><a name="1resht2taubqmns7669bqo6aa4">View点击、滑动事件相关</a><br></h2><br><h3 class="topic"><br><a name="5qk4p9ddfq64uovv6am7sl871h">&nbsp;基础知识</a><br></h3><br><h3 class="topic"><br><a name="782mmr5phdmtjhrs4o1mfcfgsk">&nbsp;&nbsp;view坐标</a><br></h3><br><h3 class="topic"><br><a name="19t9d50furj2p0icv9oha24f2k">&nbsp;&nbsp;&nbsp;top、left、right、bottom：<br>分别是view左上角的纵坐标、横坐标，右下角的横坐标、纵坐标。它们都是相对于父容器的，并且在view平移过程中，这4个值不会改变。</a><br></h3><br><h3 class="topic"><br><a name="1jr1avvtivcqg4uqr3p28jd4kv">&nbsp;&nbsp;&nbsp;x、y：<br>view的左上角坐标，当view移动时这两个值会改变。</a><br></h3><br><h3 class="topic"><br><a name="1kc34kaeeei4tnuusi6q6il62d">&nbsp;&nbsp;&nbsp;translationX、translationY:<br>view左上角相对于父容器的偏移量，会随着view的移动过而改变。</a><br></h3><br><h3 class="topic"><br><a name="1f93vai0vme8hn81fuom4lj2rf">&nbsp;&nbsp;&nbsp;3者的联系：<br>x = left + translationX<br>y = top + translationY</a><br></h3><br><p class="summary">(<a href="#19t9d50furj2p0icv9oha24f2k">top、left、right、bottom：<br>分别是view左上角的纵坐标、横坐标，右下角的横坐标、纵坐标。它们都是相对于父容器的，并且在view平移过程中，这4个值不会改变。</a>, <a href="#1jr1avvtivcqg4uqr3p28jd4kv">x、y：<br>view的左上角坐标，当view移动时这两个值会改变。</a>, <a href="#1kc34kaeeei4tnuusi6q6il62d">translationX、translationY:<br>view左上角相对于父容器的偏移量，会随着view的移动过而改变。</a>)</p><br><h3 class="topic"><br><a name="59ocgvb6tesnldosiv2e6udet3">&nbsp;&nbsp;触摸事件坐标：<br>通过MotionEvent对象获取坐标</a><br></h3><br><h3 class="topic"><br><a name="71h9kgnpjq26c6lea0ko327u2u">&nbsp;&nbsp;&nbsp;getX/getY返回的是相对于当前View左上角的x和y坐标</a><br></h3><br><h3 class="topic"><br><a name="7g0do8hg7jql1sbqnvl0rn0193">&nbsp;&nbsp;&nbsp;getRawX/getRawY返回的是相对于手机屏幕左上角的x和y坐标</a><br></h3><br><h3 class="topic"><br><a name="4hlg21g8c0lgs286m5e8smuors">&nbsp;&nbsp;工具类</a><br></h3><br><h3 class="topic"><br><a name="3606ubdi6gnl8lpv6a7tgml5hd">&nbsp;&nbsp;&nbsp;VelocityTracker：速度追踪</a><br></h3><br><h3 class="topic"><br><a name="70auaotp1nojdl336u3rce8ggi">&nbsp;&nbsp;&nbsp;GestureDectector：手势检测，可用于检测单击、滑动、长按、双击等</a><br></h3><br><h3 class="topic"><br><a name="5jloe2p330eood9njf5hfngtrc">&nbsp;&nbsp;&nbsp;Scroller：弹性滑动</a><br></h3><br><h3 class="topic"><br><a name="57fgc7uolode36ng81n7l2l69e">&nbsp;View的滑动</a><br></h3><br><h3 class="topic"><br><a name="3gnmo7ahstcuspe0p6kke33oj5">&nbsp;&nbsp;使用scrollTo/scrollBy</a><br></h3><br><h3 class="topic"><br><a name="5032dbp1kqt4hsl8jpvu9ge5hn">&nbsp;&nbsp;&nbsp;在滑动过程中，mScrollX的值总是等于View左边缘和View内容左边缘在水平方向的距离，mScrollY亦然。<br>View边缘是指View的位置，由四个顶点组成，而View内容边缘是指View中的内容的边缘。scrollTo和scrollBy只能改变View内容的位置而不能改变View在布局中的位置。当View左边缘在View内容左边缘的右边时，mScrollX为正值，反之为负值。换句话说，如果从左向右滑动，那么mScrollX为负值，反之为正值。mScrollY亦然。</a><br></h3><br><h3 class="topic"><br><a name="5ss75qr84lg9j0qd4are88qvr2">&nbsp;&nbsp;使用动画</a><br></h3><br><h3 class="topic"><br><a name="48ajgv6dinj1v90n4ipt5gqpju">&nbsp;&nbsp;&nbsp;View动画：只能移动影像，实际view的位置并没有变化。这就导致，用view动画使一个按钮向右移动了100dp，但实际去点击按钮所在的新位置时并不会有响应，而点击按钮原来的位置（现在已近不再此位置）却会有响应。</a><br></h3><br><h3 class="topic"><br><a name="4uoffd75ed0uh0j1m4lq692ve3">&nbsp;&nbsp;&nbsp;属性动画：可以解决上面的问题，但从Android3.0才支持属性动画。</a><br></h3><br><h3 class="topic"><br><a name="4u34hum0ornlb9400noatq3sa0">&nbsp;&nbsp;改变布局参数。即修改LayoutParams。</a><br></h3><br><h3 class="topic"><br><a name="36idpon9s8lt7tn4kgqbobe9a3">&nbsp;View的事件分发机制</a><br></h3><br><h3 class="topic"><br><a name="09tpevpdagubhjr5hirfai33vn">&nbsp;&nbsp;点击事件产生后按照如下顺序传递：<br>Activity -&gt; Window -&gt; View</a><br></h3><br><h3 class="topic"><br><a name="08lj9ve89onakmjil2sav9k4dr">&nbsp;&nbsp;View点击事件传递顺序：<br>dispatchTouchEvent -&gt; onInterceptTouchEvent -&gt; onTouchEvent</a><br></h3><br><h3 class="topic"><br><a name="5eufps6ujaitmv6mnsgdv23tpc">&nbsp;&nbsp;顶级View对点击事件的详细分发过程如图所示</a><br></h3><br><p class="relationships">参见: <a href="#79356njloh9d8scukv9qe3cdbp">从顶级View开始的分发过程</a><br></p><br><h3 class="topic"><br><a name="590khfsjck8jvjt2626g8q3eo2">&nbsp;&nbsp;View没有onInterceptTouchEvent方法，ViewGroup才有此方法。<br>一旦有点击事件传递给View，它的onTouchEvent方法就会被调用。</a><br></h3><br><h3 class="topic"><br><a name="2a091g4hr1t759audi67l87937">&nbsp;&nbsp;当前界面的底层容器是decor view，即setContentView所设置的View的父容器，通过Activity.getWindow.getDecorView（）可以获得。</a><br></h3><br><h3 class="topic"><br><a name="6cjp4vqge3rct2cb8bb02jj4ub">&nbsp;&nbsp;当ViewGroup决定拦截事件后，后续的点击事件将会默认交给它处理并且不再调用它的onInterceptTouchEvent方法。</a><br></h3><br><h2 class="topic"><br><a name="340ou1tk43ip16lljimds5gaf1">View工作原理</a><br></h2><br><h3 class="topic"><br><a name="4ug6t9krtqj98c1m4reb0klb63">&nbsp;View绘制相关</a><br></h3><br><h3 class="topic"><br><a name="687jro87pe54m0j9fbov1sf1ap">&nbsp;&nbsp;View的工作流程：<br>measure –&gt; layout –&gt; draw<br>其中measure确定View的测量宽/高，layout确定View的最终宽/高和四个顶点的位置，而draw将View绘制到屏幕上。</a><br></h3><br><h3 class="topic"><br><a name="0genorlinv84o48hrhbv112hkc">&nbsp;&nbsp;DecorView是顶级View，本质是一个FrameLayout，一般包含一个竖直方向的LinearLayout，这个LinearLayout有上下两部分（与Android版本和主题有关），上面是标题栏，下面是内容栏。在Activity中我们通过setContentView所设置的布局文件就是被加入到内容栏中，内容栏可以通过findViewById(android.R.id.content)来获得。</a><br></h3><br><h3 class="topic"><br><a name="2j4e1hadvgv1hm8e9bqj7sqmk2">&nbsp;&nbsp;MeasureSpec</a><br></h3><br><h3 class="topic"><br><a name="6kvqr1adbbacnnnrq8um8657cl">&nbsp;&nbsp;&nbsp;MeasureSpec是一个32位值，高2位代表SpecMode，低30位代表SpecSize。</a><br></h3><br><h3 class="topic"><br><a name="4qbihga477mp3hdr9o05pcjtpe">&nbsp;&nbsp;&nbsp;SpecMode有3类</a><br></h3><br><h3 class="topic"><br><a name="5d66fqnac009l3p8f3po32s4t6">&nbsp;&nbsp;&nbsp;&nbsp;UNSPECIFIED：父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量状态。</a><br></h3><br><h3 class="topic"><br><a name="2loimqj796hoobu72356ugec3s">&nbsp;&nbsp;&nbsp;&nbsp;EXACTLY：父容器已经检测出View所需的精确大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式。</a><br></h3><br><h3 class="topic"><br><a name="4s8sg3sgjln99edq1er0nbp4sf">&nbsp;&nbsp;&nbsp;&nbsp;AT_MOST：父容器制定了一个可用大小即SpecSize，View的大小不能大于这个值，具体是什么值要看不同View的具体实现。它对应于LayoutParams中的wrap_content。</a><br></h3><br><h3 class="topic"><br><a name="5pkce1f17n6kk6dntjak41vt9m">&nbsp;&nbsp;&nbsp;MeasureSpec转换过程</a><br></h3><br><h3 class="topic"><br><a name="1nh6u4ecp2qcgqegvpidr6qdrm">&nbsp;&nbsp;&nbsp;&nbsp;顶级View（DecorView）：MeasureSpec由窗口的尺寸和其自身的LayoutParams来共同确定。</a><br></h3><br><h3 class="topic"><br><a name="5an2rbd3ag65ef1kdkpb9c3sit">&nbsp;&nbsp;&nbsp;&nbsp;普通View：MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定</a><br></h3><br><p class="relationships">参见: <a href="#7cnj3boadme47rhlfsb6sl5mre">普通View的MeasureSpec创建规则</a><br></p><br><h3 class="topic"><br><a name="2nlj7ajav48akv13evm3a20f7q">&nbsp;&nbsp;&nbsp;&nbsp;MeasureSpec一旦确定，onMeasure中就可以确定View的测量宽/高。</a><br></h3><br><p class="summary">(<a href="#1nh6u4ecp2qcgqegvpidr6qdrm">顶级View（DecorView）：MeasureSpec由窗口的尺寸和其自身的LayoutParams来共同确定。</a>, <a href="#5an2rbd3ag65ef1kdkpb9c3sit">普通View：MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定</a>)</p><br><h3 class="topic"><br><a name="6inc3gjf956208hrrj0vene214">&nbsp;&nbsp;&nbsp;直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时自身大小，否则在布局中使用wrap_content就相当于使用match_parent。</a><br></h3><br><h3 class="topic"><br><a name="5knaeh275099jjepfg685kcbf4">&nbsp;&nbsp;如果想在Activity一启动的时候就做一件任务，但这一任务需要获取某个View的宽/高，由于View的measure过程和Activity的生命周期方法不是同步执行的，因此无法保证Activity执行了onCreate、onStart、onResume时某个View已经测量完毕了，那么获得的宽/高就是0。有以下4种方法可以解决这个问题。</a><br></h3><br><h3 class="topic"><br><a name="4igis2jrnumpkp3rrd65v5lgbn">&nbsp;&nbsp;&nbsp;Activity/View#onWindowFocusChanged：此方法会被调用多次，当Activity的window得到或失去焦点时均会被调用一次。</a><br></h3><br><h3 class="topic"><br><a name="7i8je36tdkbc1c73sie1b56qq7">&nbsp;&nbsp;&nbsp;view.post(runnable)：通过post可以将一个runnable投递到消息队列尾部，等待Looper调用此runnable的时候，View已经初始化好了，在run方法体中获取宽/高。</a><br></h3><br><h3 class="topic"><br><a name="10gpl5cfjkmspt1j0r9fjvv2dr">&nbsp;&nbsp;&nbsp;ViewTreeObserver：使用ViewTreeObserver的众多回调都可以实现。比如使用OnGlobalLayoutListener接口，当View树状态发生改变或者View树内部的View的可见性发生改变时，onGlobalLayout会被回调，可在这里获取View的宽/高，会被回调多次。</a><br></h3><br><h3 class="topic"><br><a name="7bc635itlulqdjjderaehiero5">&nbsp;&nbsp;&nbsp;view.measure：根据View的LayoutParams的类型来分别处理，较复杂。</a><br></h3><br><h3 class="topic"><br><a name="4p6ua1ldf4m7huos08g484j5f4">&nbsp;&nbsp;View默认没有启用setWillNotDraw，而ViewGroup默认启用了。</a><br></h3><br><h3 class="topic"><br><a name="1hfh724fgv1qbu4m77vbap14vk">&nbsp;自定义View</a><br></h3><br><h3 class="topic"><br><a name="0v4s3djs9ba5ogl68eh3ef64km">&nbsp;&nbsp;尽量不要在View中使用Handler，因为View内部本身提供了post系列的方法，完全可以替代Handler的作用，除非你很明确地要使用Handler来发送消息。</a><br></h3><br><h3 class="topic"><br><a name="6cmdthqk8ojupqmq175rqekbaq">&nbsp;&nbsp;View如果有现成或者动画需要停止时，那么onDetachedFromWindow是一个很好的时机。</a><br></h3><br><p class="relationships">参见: <a href="#5i2nm3uv9432n5utarufuk55em">当包含此View的Activity退出或者当前View被remove时，View的onDetachedFromWindow方法会被调用，和此方法对应的是onAttachedToWindow方法会被调用。同时，当View变得不可见时我们也需要停止线程和动画，如果不及时处理这种问题，有可能会造成内存泄露。<br></a><br></p><br><h2 class="topic"><br><a name="79356njloh9d8scukv9qe3cdbp">从顶级View开始的分发过程</a><br></h2><br><p class="topicImage"><br><img height="616" src="http://7xle8x.com1.z0.glb.clouddn.com/16-4-1/77356076.jpg" width="620"></p><br><p class="relationships">参见: <a href="#5eufps6ujaitmv6mnsgdv23tpc">顶级View对点击事件的详细分发过程如图所示</a><br></p><br><h2 class="topic"><br><a name="7cnj3boadme47rhlfsb6sl5mre">普通View的MeasureSpec创建规则</a><br></h2><br><p class="topicImage"><br><img height="155" src="http://7xle8x.com1.z0.glb.clouddn.com/16-4-1/62979652.jpg" width="568"></p><br><p class="relationships">参见: <a href="#5an2rbd3ag65ef1kdkpb9c3sit">普通View：MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定</a><br></p><br><h2 class="topic"><br><a name="5i2nm3uv9432n5utarufuk55em">当包含此View的Activity退出或者当前View被remove时，View的onDetachedFromWindow方法会被调用，和此方法对应的是onAttachedToWindow方法会被调用。同时，当View变得不可见时我们也需要停止线程和动画，如果不及时处理这种问题，有可能会造成内存泄露。<br></a><br></h2><br><p class="relationships">参见: <a href="#6cmdthqk8ojupqmq175rqekbaq">View如果有现成或者动画需要停止时，那么onDetachedFromWindow是一个很好的时机。</a><br></p><br></body><br></html>
